# Generated from CypherParser.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,99,830,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,59,
        7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,65,
        2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,72,
        7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,78,
        2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,85,
        7,85,2,86,7,86,2,87,7,87,2,88,7,88,1,0,1,0,3,0,181,8,0,1,0,1,0,1,
        1,1,1,3,1,187,8,1,1,2,1,2,5,2,191,8,2,10,2,12,2,194,9,2,1,3,1,3,
        3,3,198,8,3,1,4,1,4,1,4,3,4,203,8,4,1,4,1,4,1,4,3,4,208,8,4,3,4,
        210,8,4,1,5,1,5,1,5,1,6,1,6,1,6,3,6,218,8,6,1,7,1,7,1,7,1,8,1,8,
        1,8,1,9,3,9,227,8,9,1,9,1,9,3,9,231,8,9,1,9,3,9,234,8,9,1,9,3,9,
        237,8,9,1,10,1,10,3,10,241,8,10,1,10,1,10,5,10,245,8,10,10,10,12,
        10,248,9,10,1,11,1,11,1,11,3,11,253,8,11,1,12,1,12,3,12,257,8,12,
        1,13,1,13,1,13,1,13,1,13,5,13,264,8,13,10,13,12,13,267,9,13,1,14,
        5,14,270,8,14,10,14,12,14,273,9,14,1,14,1,14,4,14,277,8,14,11,14,
        12,14,278,1,14,3,14,282,8,14,3,14,284,8,14,1,15,5,15,287,8,15,10,
        15,12,15,290,9,15,1,15,5,15,293,8,15,10,15,12,15,296,9,15,1,15,4,
        15,299,8,15,11,15,12,15,300,1,15,1,15,1,16,3,16,306,8,16,1,16,1,
        16,1,16,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,3,18,319,8,18,1,
        19,1,19,1,19,1,19,1,19,3,19,326,8,19,1,20,3,20,329,8,20,1,20,1,20,
        1,20,1,21,1,21,1,21,1,21,5,21,338,8,21,10,21,12,21,341,9,21,1,22,
        1,22,1,22,1,22,3,22,347,8,22,1,23,1,23,1,23,1,23,1,23,3,23,354,8,
        23,1,24,1,24,3,24,358,8,24,1,24,1,24,1,25,1,25,1,25,5,25,365,8,25,
        10,25,12,25,368,9,25,1,25,3,25,371,8,25,1,26,1,26,1,26,3,26,376,
        8,26,1,26,1,26,1,27,1,27,1,27,5,27,383,8,27,10,27,12,27,386,9,27,
        1,28,1,28,1,28,1,28,1,29,1,29,1,29,1,29,5,29,396,8,29,10,29,12,29,
        399,9,29,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,
        3,30,412,8,30,1,31,1,31,4,31,416,8,31,11,31,12,31,417,1,32,1,32,
        1,32,1,33,1,33,3,33,425,8,33,1,34,1,34,1,34,1,35,1,35,1,35,5,35,
        433,8,35,10,35,12,35,436,9,35,1,36,1,36,1,36,5,36,441,8,36,10,36,
        12,36,444,9,36,1,37,1,37,1,37,5,37,449,8,37,10,37,12,37,452,9,37,
        1,38,1,38,1,38,5,38,457,8,38,10,38,12,38,460,9,38,1,39,3,39,463,
        8,39,1,39,1,39,1,40,1,40,1,40,1,40,5,40,471,8,40,10,40,12,40,474,
        9,40,1,41,1,41,1,42,1,42,1,42,5,42,481,8,42,10,42,12,42,484,9,42,
        1,43,1,43,1,43,5,43,489,8,43,10,43,12,43,492,9,43,1,44,1,44,1,44,
        5,44,497,8,44,10,44,12,44,500,9,44,1,45,3,45,503,8,45,1,45,1,45,
        1,46,1,46,1,46,1,46,5,46,511,8,46,10,46,12,46,514,9,46,1,47,1,47,
        1,47,1,47,3,47,520,8,47,1,47,1,47,3,47,524,8,47,1,47,3,47,527,8,
        47,1,47,3,47,530,8,47,1,48,1,48,1,48,1,49,1,49,1,49,1,49,1,49,3,
        49,540,8,49,1,50,1,50,3,50,544,8,50,1,50,1,50,1,51,1,51,3,51,550,
        8,51,1,52,1,52,1,52,5,52,555,8,52,10,52,12,52,558,9,52,1,53,1,53,
        1,53,3,53,563,8,53,1,53,1,53,1,54,1,54,5,54,569,8,54,10,54,12,54,
        572,9,54,1,54,1,54,1,54,1,54,3,54,578,8,54,1,55,1,55,1,55,1,56,1,
        56,3,56,585,8,56,1,57,1,57,3,57,589,8,57,1,57,3,57,592,8,57,1,57,
        3,57,595,8,57,1,57,1,57,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,
        1,58,1,58,1,58,1,58,3,58,611,8,58,1,59,1,59,1,59,1,60,1,60,1,60,
        3,60,619,8,60,1,60,1,60,3,60,623,8,60,1,60,1,60,3,60,627,8,60,1,
        60,1,60,3,60,631,8,60,3,60,633,8,60,1,61,1,61,3,61,637,8,61,1,61,
        3,61,640,8,61,1,61,3,61,643,8,61,1,61,3,61,646,8,61,1,61,1,61,1,
        62,1,62,1,62,1,62,3,62,654,8,62,1,62,5,62,657,8,62,10,62,12,62,660,
        9,62,1,63,1,63,3,63,664,8,63,1,63,1,63,1,64,1,64,1,64,1,64,3,64,
        672,8,64,1,64,1,64,1,65,1,65,1,65,5,65,679,8,65,10,65,12,65,682,
        9,65,1,66,1,66,1,66,3,66,687,8,66,1,66,3,66,690,8,66,1,66,1,66,1,
        67,1,67,1,67,1,67,1,68,1,68,1,68,1,68,1,68,1,69,1,69,3,69,705,8,
        69,1,69,1,69,3,69,709,8,69,1,69,1,69,1,69,1,69,1,70,1,70,4,70,717,
        8,70,11,70,12,70,718,1,71,1,71,1,71,1,71,3,71,725,8,71,1,71,1,71,
        1,72,1,72,1,72,1,72,3,72,733,8,72,1,73,1,73,1,73,1,73,1,73,1,74,
        1,74,1,74,5,74,743,8,74,10,74,12,74,746,9,74,1,75,1,75,3,75,750,
        8,75,1,75,1,75,1,75,1,75,1,75,4,75,757,8,75,11,75,12,75,758,1,75,
        1,75,3,75,763,8,75,1,75,1,75,1,76,1,76,1,76,3,76,770,8,76,1,77,1,
        77,1,77,1,77,1,77,1,77,1,77,3,77,779,8,77,1,78,1,78,3,78,783,8,78,
        1,78,1,78,3,78,787,8,78,3,78,789,8,78,1,79,1,79,1,80,1,80,1,81,1,
        81,1,82,1,82,1,83,1,83,3,83,801,8,83,1,83,1,83,1,84,1,84,1,84,1,
        84,5,84,809,8,84,10,84,12,84,812,9,84,3,84,814,8,84,1,84,1,84,1,
        85,1,85,1,85,1,85,1,86,1,86,3,86,824,8,86,1,87,1,87,1,88,1,88,1,
        88,0,0,89,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
        40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,
        84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,
        120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,
        152,154,156,158,160,162,164,166,168,170,172,174,176,0,10,2,0,37,
        38,42,43,2,0,40,40,47,47,1,0,1,2,2,0,1,1,3,7,1,0,18,19,2,0,20,21,
        23,23,1,0,33,36,1,0,71,72,2,0,30,35,89,90,1,0,36,88,864,0,178,1,
        0,0,0,2,186,1,0,0,0,4,188,1,0,0,0,6,197,1,0,0,0,8,199,1,0,0,0,10,
        211,1,0,0,0,12,214,1,0,0,0,14,219,1,0,0,0,16,222,1,0,0,0,18,226,
        1,0,0,0,20,240,1,0,0,0,22,249,1,0,0,0,24,254,1,0,0,0,26,258,1,0,
        0,0,28,271,1,0,0,0,30,288,1,0,0,0,32,305,1,0,0,0,34,310,1,0,0,0,
        36,318,1,0,0,0,38,325,1,0,0,0,40,328,1,0,0,0,42,333,1,0,0,0,44,346,
        1,0,0,0,46,348,1,0,0,0,48,355,1,0,0,0,50,361,1,0,0,0,52,375,1,0,
        0,0,54,379,1,0,0,0,56,387,1,0,0,0,58,391,1,0,0,0,60,411,1,0,0,0,
        62,415,1,0,0,0,64,419,1,0,0,0,66,422,1,0,0,0,68,426,1,0,0,0,70,429,
        1,0,0,0,72,437,1,0,0,0,74,445,1,0,0,0,76,453,1,0,0,0,78,462,1,0,
        0,0,80,466,1,0,0,0,82,475,1,0,0,0,84,477,1,0,0,0,86,485,1,0,0,0,
        88,493,1,0,0,0,90,502,1,0,0,0,92,506,1,0,0,0,94,529,1,0,0,0,96,531,
        1,0,0,0,98,539,1,0,0,0,100,541,1,0,0,0,102,547,1,0,0,0,104,551,1,
        0,0,0,106,562,1,0,0,0,108,577,1,0,0,0,110,579,1,0,0,0,112,584,1,
        0,0,0,114,586,1,0,0,0,116,610,1,0,0,0,118,612,1,0,0,0,120,632,1,
        0,0,0,122,634,1,0,0,0,124,649,1,0,0,0,126,661,1,0,0,0,128,667,1,
        0,0,0,130,675,1,0,0,0,132,683,1,0,0,0,134,693,1,0,0,0,136,697,1,
        0,0,0,138,702,1,0,0,0,140,714,1,0,0,0,142,720,1,0,0,0,144,728,1,
        0,0,0,146,734,1,0,0,0,148,739,1,0,0,0,150,747,1,0,0,0,152,766,1,
        0,0,0,154,778,1,0,0,0,156,780,1,0,0,0,158,790,1,0,0,0,160,792,1,
        0,0,0,162,794,1,0,0,0,164,796,1,0,0,0,166,798,1,0,0,0,168,804,1,
        0,0,0,170,817,1,0,0,0,172,823,1,0,0,0,174,825,1,0,0,0,176,827,1,
        0,0,0,178,180,3,2,1,0,179,181,5,9,0,0,180,179,1,0,0,0,180,181,1,
        0,0,0,181,182,1,0,0,0,182,183,5,0,0,1,183,1,1,0,0,0,184,187,3,4,
        2,0,185,187,3,8,4,0,186,184,1,0,0,0,186,185,1,0,0,0,187,3,1,0,0,
        0,188,192,3,6,3,0,189,191,3,126,63,0,190,189,1,0,0,0,191,194,1,0,
        0,0,192,190,1,0,0,0,192,193,1,0,0,0,193,5,1,0,0,0,194,192,1,0,0,
        0,195,198,3,28,14,0,196,198,3,30,15,0,197,195,1,0,0,0,197,196,1,
        0,0,0,198,7,1,0,0,0,199,200,5,28,0,0,200,202,3,130,65,0,201,203,
        3,48,24,0,202,201,1,0,0,0,202,203,1,0,0,0,203,209,1,0,0,0,204,207,
        5,29,0,0,205,208,5,23,0,0,206,208,3,50,25,0,207,205,1,0,0,0,207,
        206,1,0,0,0,208,210,1,0,0,0,209,204,1,0,0,0,209,210,1,0,0,0,210,
        9,1,0,0,0,211,212,5,53,0,0,212,213,3,18,9,0,213,11,1,0,0,0,214,215,
        5,57,0,0,215,217,3,18,9,0,216,218,3,68,34,0,217,216,1,0,0,0,217,
        218,1,0,0,0,218,13,1,0,0,0,219,220,5,55,0,0,220,221,3,72,36,0,221,
        15,1,0,0,0,222,223,5,46,0,0,223,224,3,72,36,0,224,17,1,0,0,0,225,
        227,5,63,0,0,226,225,1,0,0,0,226,227,1,0,0,0,227,228,1,0,0,0,228,
        230,3,20,10,0,229,231,3,26,13,0,230,229,1,0,0,0,230,231,1,0,0,0,
        231,233,1,0,0,0,232,234,3,14,7,0,233,232,1,0,0,0,233,234,1,0,0,0,
        234,236,1,0,0,0,235,237,3,16,8,0,236,235,1,0,0,0,236,237,1,0,0,0,
        237,19,1,0,0,0,238,241,5,23,0,0,239,241,3,22,11,0,240,238,1,0,0,
        0,240,239,1,0,0,0,241,246,1,0,0,0,242,243,5,11,0,0,243,245,3,22,
        11,0,244,242,1,0,0,0,245,248,1,0,0,0,246,244,1,0,0,0,246,247,1,0,
        0,0,247,21,1,0,0,0,248,246,1,0,0,0,249,252,3,72,36,0,250,251,5,61,
        0,0,251,253,3,174,87,0,252,250,1,0,0,0,252,253,1,0,0,0,253,23,1,
        0,0,0,254,256,3,72,36,0,255,257,7,0,0,0,256,255,1,0,0,0,256,257,
        1,0,0,0,257,25,1,0,0,0,258,259,5,51,0,0,259,260,5,39,0,0,260,265,
        3,24,12,0,261,262,5,11,0,0,262,264,3,24,12,0,263,261,1,0,0,0,264,
        267,1,0,0,0,265,263,1,0,0,0,265,266,1,0,0,0,266,27,1,0,0,0,267,265,
        1,0,0,0,268,270,3,36,18,0,269,268,1,0,0,0,270,273,1,0,0,0,271,269,
        1,0,0,0,271,272,1,0,0,0,272,283,1,0,0,0,273,271,1,0,0,0,274,284,
        3,10,5,0,275,277,3,38,19,0,276,275,1,0,0,0,277,278,1,0,0,0,278,276,
        1,0,0,0,278,279,1,0,0,0,279,281,1,0,0,0,280,282,3,10,5,0,281,280,
        1,0,0,0,281,282,1,0,0,0,282,284,1,0,0,0,283,274,1,0,0,0,283,276,
        1,0,0,0,284,29,1,0,0,0,285,287,3,36,18,0,286,285,1,0,0,0,287,290,
        1,0,0,0,288,286,1,0,0,0,288,289,1,0,0,0,289,298,1,0,0,0,290,288,
        1,0,0,0,291,293,3,38,19,0,292,291,1,0,0,0,293,296,1,0,0,0,294,292,
        1,0,0,0,294,295,1,0,0,0,295,297,1,0,0,0,296,294,1,0,0,0,297,299,
        3,12,6,0,298,294,1,0,0,0,299,300,1,0,0,0,300,298,1,0,0,0,300,301,
        1,0,0,0,301,302,1,0,0,0,302,303,3,28,14,0,303,31,1,0,0,0,304,306,
        5,50,0,0,305,304,1,0,0,0,305,306,1,0,0,0,306,307,1,0,0,0,307,308,
        5,47,0,0,308,309,3,66,33,0,309,33,1,0,0,0,310,311,5,59,0,0,311,312,
        3,72,36,0,312,313,5,61,0,0,313,314,3,174,87,0,314,35,1,0,0,0,315,
        319,3,32,16,0,316,319,3,34,17,0,317,319,3,46,23,0,318,315,1,0,0,
        0,318,316,1,0,0,0,318,317,1,0,0,0,319,37,1,0,0,0,320,326,3,64,32,
        0,321,326,3,54,27,0,322,326,3,40,20,0,323,326,3,58,29,0,324,326,
        3,42,21,0,325,320,1,0,0,0,325,321,1,0,0,0,325,322,1,0,0,0,325,323,
        1,0,0,0,325,324,1,0,0,0,326,39,1,0,0,0,327,329,5,44,0,0,328,327,
        1,0,0,0,328,329,1,0,0,0,329,330,1,0,0,0,330,331,5,41,0,0,331,332,
        3,148,74,0,332,41,1,0,0,0,333,334,5,52,0,0,334,339,3,44,22,0,335,
        336,5,11,0,0,336,338,3,44,22,0,337,335,1,0,0,0,338,341,1,0,0,0,339,
        337,1,0,0,0,339,340,1,0,0,0,340,43,1,0,0,0,341,339,1,0,0,0,342,343,
        3,174,87,0,343,344,3,62,31,0,344,347,1,0,0,0,345,347,3,104,52,0,
        346,342,1,0,0,0,346,345,1,0,0,0,347,45,1,0,0,0,348,349,5,28,0,0,
        349,350,3,130,65,0,350,353,3,48,24,0,351,352,5,29,0,0,352,354,3,
        50,25,0,353,351,1,0,0,0,353,354,1,0,0,0,354,47,1,0,0,0,355,357,5,
        12,0,0,356,358,3,148,74,0,357,356,1,0,0,0,357,358,1,0,0,0,358,359,
        1,0,0,0,359,360,5,13,0,0,360,49,1,0,0,0,361,366,3,52,26,0,362,363,
        5,11,0,0,363,365,3,52,26,0,364,362,1,0,0,0,365,368,1,0,0,0,366,364,
        1,0,0,0,366,367,1,0,0,0,367,370,1,0,0,0,368,366,1,0,0,0,369,371,
        3,68,34,0,370,369,1,0,0,0,370,371,1,0,0,0,371,51,1,0,0,0,372,373,
        3,174,87,0,373,374,5,61,0,0,374,376,1,0,0,0,375,372,1,0,0,0,375,
        376,1,0,0,0,376,377,1,0,0,0,377,378,3,174,87,0,378,53,1,0,0,0,379,
        380,5,48,0,0,380,384,3,106,53,0,381,383,3,56,28,0,382,381,1,0,0,
        0,383,386,1,0,0,0,384,382,1,0,0,0,384,385,1,0,0,0,385,55,1,0,0,0,
        386,384,1,0,0,0,387,388,5,49,0,0,388,389,7,1,0,0,389,390,3,58,29,
        0,390,57,1,0,0,0,391,392,5,54,0,0,392,397,3,60,30,0,393,394,5,11,
        0,0,394,396,3,60,30,0,395,393,1,0,0,0,396,399,1,0,0,0,397,395,1,
        0,0,0,397,398,1,0,0,0,398,59,1,0,0,0,399,397,1,0,0,0,400,401,3,104,
        52,0,401,402,5,1,0,0,402,403,3,72,36,0,403,412,1,0,0,0,404,405,3,
        174,87,0,405,406,7,2,0,0,406,407,3,72,36,0,407,412,1,0,0,0,408,409,
        3,174,87,0,409,410,3,62,31,0,410,412,1,0,0,0,411,400,1,0,0,0,411,
        404,1,0,0,0,411,408,1,0,0,0,412,61,1,0,0,0,413,414,5,25,0,0,414,
        416,3,172,86,0,415,413,1,0,0,0,416,417,1,0,0,0,417,415,1,0,0,0,417,
        418,1,0,0,0,418,63,1,0,0,0,419,420,5,40,0,0,420,421,3,70,35,0,421,
        65,1,0,0,0,422,424,3,70,35,0,423,425,3,68,34,0,424,423,1,0,0,0,424,
        425,1,0,0,0,425,67,1,0,0,0,426,427,5,56,0,0,427,428,3,72,36,0,428,
        69,1,0,0,0,429,434,3,106,53,0,430,431,5,11,0,0,431,433,3,106,53,
        0,432,430,1,0,0,0,433,436,1,0,0,0,434,432,1,0,0,0,434,435,1,0,0,
        0,435,71,1,0,0,0,436,434,1,0,0,0,437,442,3,74,37,0,438,439,5,68,
        0,0,439,441,3,74,37,0,440,438,1,0,0,0,441,444,1,0,0,0,442,440,1,
        0,0,0,442,443,1,0,0,0,443,73,1,0,0,0,444,442,1,0,0,0,445,450,3,76,
        38,0,446,447,5,70,0,0,447,449,3,76,38,0,448,446,1,0,0,0,449,452,
        1,0,0,0,450,448,1,0,0,0,450,451,1,0,0,0,451,75,1,0,0,0,452,450,1,
        0,0,0,453,458,3,78,39,0,454,455,5,60,0,0,455,457,3,78,39,0,456,454,
        1,0,0,0,457,460,1,0,0,0,458,456,1,0,0,0,458,459,1,0,0,0,459,77,1,
        0,0,0,460,458,1,0,0,0,461,463,5,67,0,0,462,461,1,0,0,0,462,463,1,
        0,0,0,463,464,1,0,0,0,464,465,3,80,40,0,465,79,1,0,0,0,466,472,3,
        84,42,0,467,468,3,82,41,0,468,469,3,84,42,0,469,471,1,0,0,0,470,
        467,1,0,0,0,471,474,1,0,0,0,472,470,1,0,0,0,472,473,1,0,0,0,473,
        81,1,0,0,0,474,472,1,0,0,0,475,476,7,3,0,0,476,83,1,0,0,0,477,482,
        3,86,43,0,478,479,7,4,0,0,479,481,3,86,43,0,480,478,1,0,0,0,481,
        484,1,0,0,0,482,480,1,0,0,0,482,483,1,0,0,0,483,85,1,0,0,0,484,482,
        1,0,0,0,485,490,3,88,44,0,486,487,7,5,0,0,487,489,3,88,44,0,488,
        486,1,0,0,0,489,492,1,0,0,0,490,488,1,0,0,0,490,491,1,0,0,0,491,
        87,1,0,0,0,492,490,1,0,0,0,493,498,3,90,45,0,494,495,5,22,0,0,495,
        497,3,90,45,0,496,494,1,0,0,0,497,500,1,0,0,0,498,496,1,0,0,0,498,
        499,1,0,0,0,499,89,1,0,0,0,500,498,1,0,0,0,501,503,7,4,0,0,502,501,
        1,0,0,0,502,503,1,0,0,0,503,504,1,0,0,0,504,505,3,92,46,0,505,91,
        1,0,0,0,506,512,3,102,51,0,507,511,3,96,48,0,508,511,3,94,47,0,509,
        511,3,100,50,0,510,507,1,0,0,0,510,508,1,0,0,0,510,509,1,0,0,0,511,
        514,1,0,0,0,512,510,1,0,0,0,512,513,1,0,0,0,513,93,1,0,0,0,514,512,
        1,0,0,0,515,516,5,65,0,0,516,530,3,102,51,0,517,526,5,16,0,0,518,
        520,3,72,36,0,519,518,1,0,0,0,519,520,1,0,0,0,520,521,1,0,0,0,521,
        523,5,8,0,0,522,524,3,72,36,0,523,522,1,0,0,0,523,524,1,0,0,0,524,
        527,1,0,0,0,525,527,3,72,36,0,526,519,1,0,0,0,526,525,1,0,0,0,527,
        528,1,0,0,0,528,530,5,17,0,0,529,515,1,0,0,0,529,517,1,0,0,0,530,
        95,1,0,0,0,531,532,3,98,49,0,532,533,3,102,51,0,533,97,1,0,0,0,534,
        535,5,69,0,0,535,540,5,57,0,0,536,537,5,64,0,0,537,540,5,57,0,0,
        538,540,5,62,0,0,539,534,1,0,0,0,539,536,1,0,0,0,539,538,1,0,0,0,
        540,99,1,0,0,0,541,543,5,66,0,0,542,544,5,67,0,0,543,542,1,0,0,0,
        543,544,1,0,0,0,544,545,1,0,0,0,545,546,5,73,0,0,546,101,1,0,0,0,
        547,549,3,104,52,0,548,550,3,62,31,0,549,548,1,0,0,0,549,550,1,0,
        0,0,550,103,1,0,0,0,551,556,3,116,58,0,552,553,5,10,0,0,553,555,
        3,172,86,0,554,552,1,0,0,0,555,558,1,0,0,0,556,554,1,0,0,0,556,557,
        1,0,0,0,557,105,1,0,0,0,558,556,1,0,0,0,559,560,3,174,87,0,560,561,
        5,1,0,0,561,563,1,0,0,0,562,559,1,0,0,0,562,563,1,0,0,0,563,564,
        1,0,0,0,564,565,3,108,54,0,565,107,1,0,0,0,566,570,3,114,57,0,567,
        569,3,110,55,0,568,567,1,0,0,0,569,572,1,0,0,0,570,568,1,0,0,0,570,
        571,1,0,0,0,571,578,1,0,0,0,572,570,1,0,0,0,573,574,5,12,0,0,574,
        575,3,108,54,0,575,576,5,13,0,0,576,578,1,0,0,0,577,566,1,0,0,0,
        577,573,1,0,0,0,578,109,1,0,0,0,579,580,3,120,60,0,580,581,3,114,
        57,0,581,111,1,0,0,0,582,585,3,168,84,0,583,585,3,152,76,0,584,582,
        1,0,0,0,584,583,1,0,0,0,585,113,1,0,0,0,586,588,5,12,0,0,587,589,
        3,174,87,0,588,587,1,0,0,0,588,589,1,0,0,0,589,591,1,0,0,0,590,592,
        3,62,31,0,591,590,1,0,0,0,591,592,1,0,0,0,592,594,1,0,0,0,593,595,
        3,112,56,0,594,593,1,0,0,0,594,595,1,0,0,0,595,596,1,0,0,0,596,597,
        5,13,0,0,597,115,1,0,0,0,598,611,3,154,77,0,599,611,3,152,76,0,600,
        611,3,150,75,0,601,611,3,146,73,0,602,611,3,142,71,0,603,611,3,138,
        69,0,604,611,3,136,68,0,605,611,3,140,70,0,606,611,3,134,67,0,607,
        611,3,132,66,0,608,611,3,174,87,0,609,611,3,128,64,0,610,598,1,0,
        0,0,610,599,1,0,0,0,610,600,1,0,0,0,610,601,1,0,0,0,610,602,1,0,
        0,0,610,603,1,0,0,0,610,604,1,0,0,0,610,605,1,0,0,0,610,606,1,0,
        0,0,610,607,1,0,0,0,610,608,1,0,0,0,610,609,1,0,0,0,611,117,1,0,
        0,0,612,613,3,174,87,0,613,614,5,1,0,0,614,119,1,0,0,0,615,616,5,
        6,0,0,616,618,5,18,0,0,617,619,3,122,61,0,618,617,1,0,0,0,618,619,
        1,0,0,0,619,620,1,0,0,0,620,622,5,18,0,0,621,623,5,5,0,0,622,621,
        1,0,0,0,622,623,1,0,0,0,623,633,1,0,0,0,624,626,5,18,0,0,625,627,
        3,122,61,0,626,625,1,0,0,0,626,627,1,0,0,0,627,628,1,0,0,0,628,630,
        5,18,0,0,629,631,5,5,0,0,630,629,1,0,0,0,630,631,1,0,0,0,631,633,
        1,0,0,0,632,615,1,0,0,0,632,624,1,0,0,0,633,121,1,0,0,0,634,636,
        5,16,0,0,635,637,3,174,87,0,636,635,1,0,0,0,636,637,1,0,0,0,637,
        639,1,0,0,0,638,640,3,124,62,0,639,638,1,0,0,0,639,640,1,0,0,0,640,
        642,1,0,0,0,641,643,3,156,78,0,642,641,1,0,0,0,642,643,1,0,0,0,643,
        645,1,0,0,0,644,646,3,112,56,0,645,644,1,0,0,0,645,646,1,0,0,0,646,
        647,1,0,0,0,647,648,5,17,0,0,648,123,1,0,0,0,649,650,5,25,0,0,650,
        658,3,172,86,0,651,653,5,26,0,0,652,654,5,25,0,0,653,652,1,0,0,0,
        653,654,1,0,0,0,654,655,1,0,0,0,655,657,3,172,86,0,656,651,1,0,0,
        0,657,660,1,0,0,0,658,656,1,0,0,0,658,659,1,0,0,0,659,125,1,0,0,
        0,660,658,1,0,0,0,661,663,5,58,0,0,662,664,5,36,0,0,663,662,1,0,
        0,0,663,664,1,0,0,0,664,665,1,0,0,0,665,666,3,6,3,0,666,127,1,0,
        0,0,667,668,5,45,0,0,668,671,5,14,0,0,669,672,3,4,2,0,670,672,3,
        66,33,0,671,669,1,0,0,0,671,670,1,0,0,0,672,673,1,0,0,0,673,674,
        5,15,0,0,674,129,1,0,0,0,675,680,3,174,87,0,676,677,5,10,0,0,677,
        679,3,174,87,0,678,676,1,0,0,0,679,682,1,0,0,0,680,678,1,0,0,0,680,
        681,1,0,0,0,681,131,1,0,0,0,682,680,1,0,0,0,683,684,3,130,65,0,684,
        686,5,12,0,0,685,687,5,63,0,0,686,685,1,0,0,0,686,687,1,0,0,0,687,
        689,1,0,0,0,688,690,3,148,74,0,689,688,1,0,0,0,689,690,1,0,0,0,690,
        691,1,0,0,0,691,692,5,13,0,0,692,133,1,0,0,0,693,694,5,12,0,0,694,
        695,3,72,36,0,695,696,5,13,0,0,696,135,1,0,0,0,697,698,7,6,0,0,698,
        699,5,12,0,0,699,700,3,144,72,0,700,701,5,13,0,0,701,137,1,0,0,0,
        702,704,5,16,0,0,703,705,3,118,59,0,704,703,1,0,0,0,704,705,1,0,
        0,0,705,706,1,0,0,0,706,708,3,140,70,0,707,709,3,68,34,0,708,707,
        1,0,0,0,708,709,1,0,0,0,709,710,1,0,0,0,710,711,5,26,0,0,711,712,
        3,72,36,0,712,713,5,17,0,0,713,139,1,0,0,0,714,716,3,114,57,0,715,
        717,3,110,55,0,716,715,1,0,0,0,717,718,1,0,0,0,718,716,1,0,0,0,718,
        719,1,0,0,0,719,141,1,0,0,0,720,721,5,16,0,0,721,724,3,144,72,0,
        722,723,5,26,0,0,723,725,3,72,36,0,724,722,1,0,0,0,724,725,1,0,0,
        0,725,726,1,0,0,0,726,727,5,17,0,0,727,143,1,0,0,0,728,729,3,174,
        87,0,729,730,5,65,0,0,730,732,3,72,36,0,731,733,3,68,34,0,732,731,
        1,0,0,0,732,733,1,0,0,0,733,145,1,0,0,0,734,735,5,32,0,0,735,736,
        5,12,0,0,736,737,5,23,0,0,737,738,5,13,0,0,738,147,1,0,0,0,739,744,
        3,72,36,0,740,741,5,11,0,0,741,743,3,72,36,0,742,740,1,0,0,0,743,
        746,1,0,0,0,744,742,1,0,0,0,744,745,1,0,0,0,745,149,1,0,0,0,746,
        744,1,0,0,0,747,749,5,79,0,0,748,750,3,72,36,0,749,748,1,0,0,0,749,
        750,1,0,0,0,750,756,1,0,0,0,751,752,5,80,0,0,752,753,3,72,36,0,753,
        754,5,81,0,0,754,755,3,72,36,0,755,757,1,0,0,0,756,751,1,0,0,0,757,
        758,1,0,0,0,758,756,1,0,0,0,758,759,1,0,0,0,759,762,1,0,0,0,760,
        761,5,82,0,0,761,763,3,72,36,0,762,760,1,0,0,0,762,763,1,0,0,0,763,
        764,1,0,0,0,764,765,5,83,0,0,765,151,1,0,0,0,766,769,5,27,0,0,767,
        770,3,174,87,0,768,770,3,160,80,0,769,767,1,0,0,0,769,768,1,0,0,
        0,770,153,1,0,0,0,771,779,3,158,79,0,772,779,3,160,80,0,773,779,
        5,73,0,0,774,779,3,162,81,0,775,779,3,164,82,0,776,779,3,166,83,
        0,777,779,3,168,84,0,778,771,1,0,0,0,778,772,1,0,0,0,778,773,1,0,
        0,0,778,774,1,0,0,0,778,775,1,0,0,0,778,776,1,0,0,0,778,777,1,0,
        0,0,779,155,1,0,0,0,780,782,5,23,0,0,781,783,3,160,80,0,782,781,
        1,0,0,0,782,783,1,0,0,0,783,788,1,0,0,0,784,786,5,8,0,0,785,787,
        3,160,80,0,786,785,1,0,0,0,786,787,1,0,0,0,787,789,1,0,0,0,788,784,
        1,0,0,0,788,789,1,0,0,0,789,157,1,0,0,0,790,791,7,7,0,0,791,159,
        1,0,0,0,792,793,5,93,0,0,793,161,1,0,0,0,794,795,5,92,0,0,795,163,
        1,0,0,0,796,797,5,91,0,0,797,165,1,0,0,0,798,800,5,16,0,0,799,801,
        3,148,74,0,800,799,1,0,0,0,800,801,1,0,0,0,801,802,1,0,0,0,802,803,
        5,17,0,0,803,167,1,0,0,0,804,813,5,14,0,0,805,810,3,170,85,0,806,
        807,5,11,0,0,807,809,3,170,85,0,808,806,1,0,0,0,809,812,1,0,0,0,
        810,808,1,0,0,0,810,811,1,0,0,0,811,814,1,0,0,0,812,810,1,0,0,0,
        813,805,1,0,0,0,813,814,1,0,0,0,814,815,1,0,0,0,815,816,5,15,0,0,
        816,169,1,0,0,0,817,818,3,172,86,0,818,819,5,25,0,0,819,820,3,72,
        36,0,820,171,1,0,0,0,821,824,3,174,87,0,822,824,3,176,88,0,823,821,
        1,0,0,0,823,822,1,0,0,0,824,173,1,0,0,0,825,826,7,8,0,0,826,175,
        1,0,0,0,827,828,7,9,0,0,828,177,1,0,0,0,102,180,186,192,197,202,
        207,209,217,226,230,233,236,240,246,252,256,265,271,278,281,283,
        288,294,300,305,318,325,328,339,346,353,357,366,370,375,384,397,
        411,417,424,434,442,450,458,462,472,482,490,498,502,510,512,519,
        523,526,529,539,543,549,556,562,570,577,584,588,591,594,610,618,
        622,626,630,632,636,639,642,645,653,658,663,671,680,686,689,704,
        708,718,724,732,744,749,758,762,769,778,782,786,788,800,810,813,
        823
    ]

class CypherParser ( Parser ):

    grammarFileName = "CypherParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'='", "'+='", "'<='", "'>='", "'>'", 
                     "'<'", "'<>'", "'..'", "';'", "'.'", "','", "'('", 
                     "')'", "'{'", "'}'", "'['", "']'", "'-'", "'+'", "'/'", 
                     "'%'", "'^'", "'*'", "'`'", "':'", "'|'", "'$'", "'CALL'", 
                     "'YIELD'", "'FILTER'", "'EXTRACT'", "'COUNT'", "'ANY'", 
                     "'NONE'", "'SINGLE'", "'ALL'", "'ASC'", "'ASCENDING'", 
                     "'BY'", "'CREATE'", "'DELETE'", "'DESC'", "'DESCENDING'", 
                     "'DETACH'", "'EXISTS'", "'LIMIT'", "'MATCH'", "'MERGE'", 
                     "'ON'", "'OPTIONAL'", "'ORDER'", "'REMOVE'", "'RETURN'", 
                     "'SET'", "'SKIP'", "'WHERE'", "'WITH'", "'UNION'", 
                     "'UNWIND'", "'AND'", "'AS'", "'CONTAINS'", "'DISTINCT'", 
                     "'ENDS'", "'IN'", "'IS'", "'NOT'", "'OR'", "'STARTS'", 
                     "'XOR'", "'FALSE'", "'TRUE'", "'NULL'", "'CONSTRAINT'", 
                     "'DO'", "'FOR'", "'REQUIRE'", "'UNIQUE'", "'CASE'", 
                     "'WHEN'", "'THEN'", "'ELSE'", "'END'", "'MANDATORY'", 
                     "'SCALAR'", "'OF'", "'ADD'", "'DROP'" ]

    symbolicNames = [ "<INVALID>", "ASSIGN", "ADD_ASSIGN", "LE", "GE", "GT", 
                      "LT", "NOT_EQUAL", "RANGE", "SEMI", "DOT", "COMMA", 
                      "LPAREN", "RPAREN", "LBRACE", "RBRACE", "LBRACK", 
                      "RBRACK", "SUB", "PLUS", "DIV", "MOD", "CARET", "MULT", 
                      "ESC", "COLON", "STICK", "DOLLAR", "CALL", "YIELD", 
                      "FILTER", "EXTRACT", "COUNT", "ANY", "NONE", "SINGLE", 
                      "ALL", "ASC", "ASCENDING", "BY", "CREATE", "DELETE", 
                      "DESC", "DESCENDING", "DETACH", "EXISTS", "LIMIT", 
                      "MATCH", "MERGE", "ON", "OPTIONAL", "ORDER", "REMOVE", 
                      "RETURN", "SET", "SKIP_W", "WHERE", "WITH", "UNION", 
                      "UNWIND", "AND", "AS", "CONTAINS", "DISTINCT", "ENDS", 
                      "IN", "IS", "NOT", "OR", "STARTS", "XOR", "FALSE", 
                      "TRUE", "NULL_W", "CONSTRAINT", "DO", "FOR", "REQUIRE", 
                      "UNIQUE", "CASE", "WHEN", "THEN", "ELSE", "END", "MANDATORY", 
                      "SCALAR", "OF", "ADD", "DROP", "ID", "ESC_LITERAL", 
                      "CHAR_LITERAL", "STRING_LITERAL", "DIGIT", "FLOAT", 
                      "WS", "COMMENT", "LINE_COMMENT", "ERRCHAR", "Letter" ]

    RULE_script = 0
    RULE_query = 1
    RULE_regularQuery = 2
    RULE_singleQuery = 3
    RULE_standaloneCall = 4
    RULE_returnSt = 5
    RULE_withSt = 6
    RULE_skipSt = 7
    RULE_limitSt = 8
    RULE_projectionBody = 9
    RULE_projectionItems = 10
    RULE_projectionItem = 11
    RULE_orderItem = 12
    RULE_orderSt = 13
    RULE_singlePartQ = 14
    RULE_multiPartQ = 15
    RULE_matchSt = 16
    RULE_unwindSt = 17
    RULE_readingStatement = 18
    RULE_updatingStatement = 19
    RULE_deleteSt = 20
    RULE_removeSt = 21
    RULE_removeItem = 22
    RULE_queryCallSt = 23
    RULE_parenExpressionChain = 24
    RULE_yieldItems = 25
    RULE_yieldItem = 26
    RULE_mergeSt = 27
    RULE_mergeAction = 28
    RULE_setSt = 29
    RULE_setItem = 30
    RULE_nodeLabels = 31
    RULE_createSt = 32
    RULE_patternWhere = 33
    RULE_where = 34
    RULE_pattern = 35
    RULE_expression = 36
    RULE_xorExpression = 37
    RULE_andExpression = 38
    RULE_notExpression = 39
    RULE_comparisonExpression = 40
    RULE_comparisonSigns = 41
    RULE_addSubExpression = 42
    RULE_multDivExpression = 43
    RULE_powerExpression = 44
    RULE_unaryAddSubExpression = 45
    RULE_atomicExpression = 46
    RULE_listExpression = 47
    RULE_stringExpression = 48
    RULE_stringExpPrefix = 49
    RULE_nullExpression = 50
    RULE_propertyOrLabelExpression = 51
    RULE_propertyExpression = 52
    RULE_patternPart = 53
    RULE_patternElem = 54
    RULE_patternElemChain = 55
    RULE_properties = 56
    RULE_nodePattern = 57
    RULE_atom = 58
    RULE_lhs = 59
    RULE_relationshipPattern = 60
    RULE_relationDetail = 61
    RULE_relationshipTypes = 62
    RULE_unionSt = 63
    RULE_subqueryExist = 64
    RULE_invocationName = 65
    RULE_functionInvocation = 66
    RULE_parenthesizedExpression = 67
    RULE_filterWith = 68
    RULE_patternComprehension = 69
    RULE_relationshipsChainPattern = 70
    RULE_listComprehension = 71
    RULE_filterExpression = 72
    RULE_countAll = 73
    RULE_expressionChain = 74
    RULE_caseExpression = 75
    RULE_parameter = 76
    RULE_literal = 77
    RULE_rangeLit = 78
    RULE_boolLit = 79
    RULE_numLit = 80
    RULE_stringLit = 81
    RULE_charLit = 82
    RULE_listLit = 83
    RULE_mapLit = 84
    RULE_mapPair = 85
    RULE_name = 86
    RULE_symbol = 87
    RULE_reservedWord = 88

    ruleNames =  [ "script", "query", "regularQuery", "singleQuery", "standaloneCall", 
                   "returnSt", "withSt", "skipSt", "limitSt", "projectionBody", 
                   "projectionItems", "projectionItem", "orderItem", "orderSt", 
                   "singlePartQ", "multiPartQ", "matchSt", "unwindSt", "readingStatement", 
                   "updatingStatement", "deleteSt", "removeSt", "removeItem", 
                   "queryCallSt", "parenExpressionChain", "yieldItems", 
                   "yieldItem", "mergeSt", "mergeAction", "setSt", "setItem", 
                   "nodeLabels", "createSt", "patternWhere", "where", "pattern", 
                   "expression", "xorExpression", "andExpression", "notExpression", 
                   "comparisonExpression", "comparisonSigns", "addSubExpression", 
                   "multDivExpression", "powerExpression", "unaryAddSubExpression", 
                   "atomicExpression", "listExpression", "stringExpression", 
                   "stringExpPrefix", "nullExpression", "propertyOrLabelExpression", 
                   "propertyExpression", "patternPart", "patternElem", "patternElemChain", 
                   "properties", "nodePattern", "atom", "lhs", "relationshipPattern", 
                   "relationDetail", "relationshipTypes", "unionSt", "subqueryExist", 
                   "invocationName", "functionInvocation", "parenthesizedExpression", 
                   "filterWith", "patternComprehension", "relationshipsChainPattern", 
                   "listComprehension", "filterExpression", "countAll", 
                   "expressionChain", "caseExpression", "parameter", "literal", 
                   "rangeLit", "boolLit", "numLit", "stringLit", "charLit", 
                   "listLit", "mapLit", "mapPair", "name", "symbol", "reservedWord" ]

    EOF = Token.EOF
    ASSIGN=1
    ADD_ASSIGN=2
    LE=3
    GE=4
    GT=5
    LT=6
    NOT_EQUAL=7
    RANGE=8
    SEMI=9
    DOT=10
    COMMA=11
    LPAREN=12
    RPAREN=13
    LBRACE=14
    RBRACE=15
    LBRACK=16
    RBRACK=17
    SUB=18
    PLUS=19
    DIV=20
    MOD=21
    CARET=22
    MULT=23
    ESC=24
    COLON=25
    STICK=26
    DOLLAR=27
    CALL=28
    YIELD=29
    FILTER=30
    EXTRACT=31
    COUNT=32
    ANY=33
    NONE=34
    SINGLE=35
    ALL=36
    ASC=37
    ASCENDING=38
    BY=39
    CREATE=40
    DELETE=41
    DESC=42
    DESCENDING=43
    DETACH=44
    EXISTS=45
    LIMIT=46
    MATCH=47
    MERGE=48
    ON=49
    OPTIONAL=50
    ORDER=51
    REMOVE=52
    RETURN=53
    SET=54
    SKIP_W=55
    WHERE=56
    WITH=57
    UNION=58
    UNWIND=59
    AND=60
    AS=61
    CONTAINS=62
    DISTINCT=63
    ENDS=64
    IN=65
    IS=66
    NOT=67
    OR=68
    STARTS=69
    XOR=70
    FALSE=71
    TRUE=72
    NULL_W=73
    CONSTRAINT=74
    DO=75
    FOR=76
    REQUIRE=77
    UNIQUE=78
    CASE=79
    WHEN=80
    THEN=81
    ELSE=82
    END=83
    MANDATORY=84
    SCALAR=85
    OF=86
    ADD=87
    DROP=88
    ID=89
    ESC_LITERAL=90
    CHAR_LITERAL=91
    STRING_LITERAL=92
    DIGIT=93
    FLOAT=94
    WS=95
    COMMENT=96
    LINE_COMMENT=97
    ERRCHAR=98
    Letter=99

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ScriptContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def query(self):
            return self.getTypedRuleContext(CypherParser.QueryContext,0)


        def EOF(self):
            return self.getToken(CypherParser.EOF, 0)

        def SEMI(self):
            return self.getToken(CypherParser.SEMI, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_script

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScript" ):
                listener.enterScript(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScript" ):
                listener.exitScript(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScript" ):
                return visitor.visitScript(self)
            else:
                return visitor.visitChildren(self)




    def script(self):

        localctx = CypherParser.ScriptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_script)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            self.query()
            self.state = 180
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==9:
                self.state = 179
                self.match(CypherParser.SEMI)


            self.state = 182
            self.match(CypherParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def regularQuery(self):
            return self.getTypedRuleContext(CypherParser.RegularQueryContext,0)


        def standaloneCall(self):
            return self.getTypedRuleContext(CypherParser.StandaloneCallContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery" ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery" ):
                listener.exitQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuery" ):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)




    def query(self):

        localctx = CypherParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_query)
        try:
            self.state = 186
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 184
                self.regularQuery()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 185
                self.standaloneCall()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegularQueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleQuery(self):
            return self.getTypedRuleContext(CypherParser.SingleQueryContext,0)


        def unionSt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.UnionStContext)
            else:
                return self.getTypedRuleContext(CypherParser.UnionStContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_regularQuery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegularQuery" ):
                listener.enterRegularQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegularQuery" ):
                listener.exitRegularQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegularQuery" ):
                return visitor.visitRegularQuery(self)
            else:
                return visitor.visitChildren(self)




    def regularQuery(self):

        localctx = CypherParser.RegularQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_regularQuery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 188
            self.singleQuery()
            self.state = 192
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==58:
                self.state = 189
                self.unionSt()
                self.state = 194
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleQueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singlePartQ(self):
            return self.getTypedRuleContext(CypherParser.SinglePartQContext,0)


        def multiPartQ(self):
            return self.getTypedRuleContext(CypherParser.MultiPartQContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_singleQuery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleQuery" ):
                listener.enterSingleQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleQuery" ):
                listener.exitSingleQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleQuery" ):
                return visitor.visitSingleQuery(self)
            else:
                return visitor.visitChildren(self)




    def singleQuery(self):

        localctx = CypherParser.SingleQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_singleQuery)
        try:
            self.state = 197
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 195
                self.singlePartQ()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 196
                self.multiPartQ()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StandaloneCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CALL(self):
            return self.getToken(CypherParser.CALL, 0)

        def invocationName(self):
            return self.getTypedRuleContext(CypherParser.InvocationNameContext,0)


        def parenExpressionChain(self):
            return self.getTypedRuleContext(CypherParser.ParenExpressionChainContext,0)


        def YIELD(self):
            return self.getToken(CypherParser.YIELD, 0)

        def MULT(self):
            return self.getToken(CypherParser.MULT, 0)

        def yieldItems(self):
            return self.getTypedRuleContext(CypherParser.YieldItemsContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_standaloneCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStandaloneCall" ):
                listener.enterStandaloneCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStandaloneCall" ):
                listener.exitStandaloneCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStandaloneCall" ):
                return visitor.visitStandaloneCall(self)
            else:
                return visitor.visitChildren(self)




    def standaloneCall(self):

        localctx = CypherParser.StandaloneCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_standaloneCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.match(CypherParser.CALL)
            self.state = 200
            self.invocationName()
            self.state = 202
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 201
                self.parenExpressionChain()


            self.state = 209
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==29:
                self.state = 204
                self.match(CypherParser.YIELD)
                self.state = 207
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [23]:
                    self.state = 205
                    self.match(CypherParser.MULT)
                    pass
                elif token in [30, 31, 32, 33, 34, 35, 89, 90]:
                    self.state = 206
                    self.yieldItems()
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(CypherParser.RETURN, 0)

        def projectionBody(self):
            return self.getTypedRuleContext(CypherParser.ProjectionBodyContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_returnSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnSt" ):
                listener.enterReturnSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnSt" ):
                listener.exitReturnSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnSt" ):
                return visitor.visitReturnSt(self)
            else:
                return visitor.visitChildren(self)




    def returnSt(self):

        localctx = CypherParser.ReturnStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_returnSt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.match(CypherParser.RETURN)
            self.state = 212
            self.projectionBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(CypherParser.WITH, 0)

        def projectionBody(self):
            return self.getTypedRuleContext(CypherParser.ProjectionBodyContext,0)


        def where(self):
            return self.getTypedRuleContext(CypherParser.WhereContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_withSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithSt" ):
                listener.enterWithSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithSt" ):
                listener.exitWithSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWithSt" ):
                return visitor.visitWithSt(self)
            else:
                return visitor.visitChildren(self)




    def withSt(self):

        localctx = CypherParser.WithStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_withSt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.match(CypherParser.WITH)
            self.state = 215
            self.projectionBody()
            self.state = 217
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==56:
                self.state = 216
                self.where()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SkipStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SKIP_W(self):
            return self.getToken(CypherParser.SKIP_W, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_skipSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSkipSt" ):
                listener.enterSkipSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSkipSt" ):
                listener.exitSkipSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSkipSt" ):
                return visitor.visitSkipSt(self)
            else:
                return visitor.visitChildren(self)




    def skipSt(self):

        localctx = CypherParser.SkipStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_skipSt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            self.match(CypherParser.SKIP_W)
            self.state = 220
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LimitStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIMIT(self):
            return self.getToken(CypherParser.LIMIT, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_limitSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimitSt" ):
                listener.enterLimitSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimitSt" ):
                listener.exitLimitSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimitSt" ):
                return visitor.visitLimitSt(self)
            else:
                return visitor.visitChildren(self)




    def limitSt(self):

        localctx = CypherParser.LimitStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_limitSt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 222
            self.match(CypherParser.LIMIT)
            self.state = 223
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectionBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def projectionItems(self):
            return self.getTypedRuleContext(CypherParser.ProjectionItemsContext,0)


        def DISTINCT(self):
            return self.getToken(CypherParser.DISTINCT, 0)

        def orderSt(self):
            return self.getTypedRuleContext(CypherParser.OrderStContext,0)


        def skipSt(self):
            return self.getTypedRuleContext(CypherParser.SkipStContext,0)


        def limitSt(self):
            return self.getTypedRuleContext(CypherParser.LimitStContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_projectionBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProjectionBody" ):
                listener.enterProjectionBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProjectionBody" ):
                listener.exitProjectionBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProjectionBody" ):
                return visitor.visitProjectionBody(self)
            else:
                return visitor.visitChildren(self)




    def projectionBody(self):

        localctx = CypherParser.ProjectionBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_projectionBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==63:
                self.state = 225
                self.match(CypherParser.DISTINCT)


            self.state = 228
            self.projectionItems()
            self.state = 230
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==51:
                self.state = 229
                self.orderSt()


            self.state = 233
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==55:
                self.state = 232
                self.skipSt()


            self.state = 236
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==46:
                self.state = 235
                self.limitSt()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectionItemsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULT(self):
            return self.getToken(CypherParser.MULT, 0)

        def projectionItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ProjectionItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.ProjectionItemContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.COMMA)
            else:
                return self.getToken(CypherParser.COMMA, i)

        def getRuleIndex(self):
            return CypherParser.RULE_projectionItems

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProjectionItems" ):
                listener.enterProjectionItems(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProjectionItems" ):
                listener.exitProjectionItems(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProjectionItems" ):
                return visitor.visitProjectionItems(self)
            else:
                return visitor.visitChildren(self)




    def projectionItems(self):

        localctx = CypherParser.ProjectionItemsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_projectionItems)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [23]:
                self.state = 238
                self.match(CypherParser.MULT)
                pass
            elif token in [12, 14, 16, 18, 19, 27, 30, 31, 32, 33, 34, 35, 36, 45, 67, 71, 72, 73, 79, 89, 90, 91, 92, 93]:
                self.state = 239
                self.projectionItem()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 246
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 242
                self.match(CypherParser.COMMA)
                self.state = 243
                self.projectionItem()
                self.state = 248
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectionItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def AS(self):
            return self.getToken(CypherParser.AS, 0)

        def symbol(self):
            return self.getTypedRuleContext(CypherParser.SymbolContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_projectionItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProjectionItem" ):
                listener.enterProjectionItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProjectionItem" ):
                listener.exitProjectionItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProjectionItem" ):
                return visitor.visitProjectionItem(self)
            else:
                return visitor.visitChildren(self)




    def projectionItem(self):

        localctx = CypherParser.ProjectionItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_projectionItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.expression()
            self.state = 252
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==61:
                self.state = 250
                self.match(CypherParser.AS)
                self.state = 251
                self.symbol()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def ASCENDING(self):
            return self.getToken(CypherParser.ASCENDING, 0)

        def ASC(self):
            return self.getToken(CypherParser.ASC, 0)

        def DESCENDING(self):
            return self.getToken(CypherParser.DESCENDING, 0)

        def DESC(self):
            return self.getToken(CypherParser.DESC, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_orderItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderItem" ):
                listener.enterOrderItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderItem" ):
                listener.exitOrderItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderItem" ):
                return visitor.visitOrderItem(self)
            else:
                return visitor.visitChildren(self)




    def orderItem(self):

        localctx = CypherParser.OrderItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_orderItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self.expression()
            self.state = 256
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 13606456393728) != 0):
                self.state = 255
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 13606456393728) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER(self):
            return self.getToken(CypherParser.ORDER, 0)

        def BY(self):
            return self.getToken(CypherParser.BY, 0)

        def orderItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.OrderItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.OrderItemContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.COMMA)
            else:
                return self.getToken(CypherParser.COMMA, i)

        def getRuleIndex(self):
            return CypherParser.RULE_orderSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderSt" ):
                listener.enterOrderSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderSt" ):
                listener.exitOrderSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderSt" ):
                return visitor.visitOrderSt(self)
            else:
                return visitor.visitChildren(self)




    def orderSt(self):

        localctx = CypherParser.OrderStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_orderSt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self.match(CypherParser.ORDER)
            self.state = 259
            self.match(CypherParser.BY)
            self.state = 260
            self.orderItem()
            self.state = 265
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 261
                self.match(CypherParser.COMMA)
                self.state = 262
                self.orderItem()
                self.state = 267
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SinglePartQContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def returnSt(self):
            return self.getTypedRuleContext(CypherParser.ReturnStContext,0)


        def readingStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ReadingStatementContext)
            else:
                return self.getTypedRuleContext(CypherParser.ReadingStatementContext,i)


        def updatingStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.UpdatingStatementContext)
            else:
                return self.getTypedRuleContext(CypherParser.UpdatingStatementContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_singlePartQ

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSinglePartQ" ):
                listener.enterSinglePartQ(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSinglePartQ" ):
                listener.exitSinglePartQ(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSinglePartQ" ):
                return visitor.visitSinglePartQ(self)
            else:
                return visitor.visitChildren(self)




    def singlePartQ(self):

        localctx = CypherParser.SinglePartQContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_singlePartQ)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 577727389967056896) != 0):
                self.state = 268
                self.readingStatement()
                self.state = 273
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 283
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [53]:
                self.state = 274
                self.returnSt()
                pass
            elif token in [40, 41, 44, 48, 52, 54]:
                self.state = 276 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 275
                    self.updatingStatement()
                    self.state = 278 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 22820363834490880) != 0)):
                        break

                self.state = 281
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==53:
                    self.state = 280
                    self.returnSt()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiPartQContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singlePartQ(self):
            return self.getTypedRuleContext(CypherParser.SinglePartQContext,0)


        def readingStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ReadingStatementContext)
            else:
                return self.getTypedRuleContext(CypherParser.ReadingStatementContext,i)


        def withSt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.WithStContext)
            else:
                return self.getTypedRuleContext(CypherParser.WithStContext,i)


        def updatingStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.UpdatingStatementContext)
            else:
                return self.getTypedRuleContext(CypherParser.UpdatingStatementContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_multiPartQ

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiPartQ" ):
                listener.enterMultiPartQ(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiPartQ" ):
                listener.exitMultiPartQ(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiPartQ" ):
                return visitor.visitMultiPartQ(self)
            else:
                return visitor.visitChildren(self)




    def multiPartQ(self):

        localctx = CypherParser.MultiPartQContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_multiPartQ)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 577727389967056896) != 0):
                self.state = 285
                self.readingStatement()
                self.state = 290
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 298 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 294
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while (((_la) & ~0x3f) == 0 and ((1 << _la) & 22820363834490880) != 0):
                        self.state = 291
                        self.updatingStatement()
                        self.state = 296
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 297
                    self.withSt()

                else:
                    raise NoViableAltException(self)
                self.state = 300 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,23,self._ctx)

            self.state = 302
            self.singlePartQ()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatchStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MATCH(self):
            return self.getToken(CypherParser.MATCH, 0)

        def patternWhere(self):
            return self.getTypedRuleContext(CypherParser.PatternWhereContext,0)


        def OPTIONAL(self):
            return self.getToken(CypherParser.OPTIONAL, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_matchSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatchSt" ):
                listener.enterMatchSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatchSt" ):
                listener.exitMatchSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatchSt" ):
                return visitor.visitMatchSt(self)
            else:
                return visitor.visitChildren(self)




    def matchSt(self):

        localctx = CypherParser.MatchStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_matchSt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 305
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==50:
                self.state = 304
                self.match(CypherParser.OPTIONAL)


            self.state = 307
            self.match(CypherParser.MATCH)
            self.state = 308
            self.patternWhere()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnwindStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNWIND(self):
            return self.getToken(CypherParser.UNWIND, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def AS(self):
            return self.getToken(CypherParser.AS, 0)

        def symbol(self):
            return self.getTypedRuleContext(CypherParser.SymbolContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_unwindSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnwindSt" ):
                listener.enterUnwindSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnwindSt" ):
                listener.exitUnwindSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnwindSt" ):
                return visitor.visitUnwindSt(self)
            else:
                return visitor.visitChildren(self)




    def unwindSt(self):

        localctx = CypherParser.UnwindStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_unwindSt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 310
            self.match(CypherParser.UNWIND)
            self.state = 311
            self.expression()
            self.state = 312
            self.match(CypherParser.AS)
            self.state = 313
            self.symbol()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadingStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def matchSt(self):
            return self.getTypedRuleContext(CypherParser.MatchStContext,0)


        def unwindSt(self):
            return self.getTypedRuleContext(CypherParser.UnwindStContext,0)


        def queryCallSt(self):
            return self.getTypedRuleContext(CypherParser.QueryCallStContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_readingStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReadingStatement" ):
                listener.enterReadingStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReadingStatement" ):
                listener.exitReadingStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReadingStatement" ):
                return visitor.visitReadingStatement(self)
            else:
                return visitor.visitChildren(self)




    def readingStatement(self):

        localctx = CypherParser.ReadingStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_readingStatement)
        try:
            self.state = 318
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [47, 50]:
                self.enterOuterAlt(localctx, 1)
                self.state = 315
                self.matchSt()
                pass
            elif token in [59]:
                self.enterOuterAlt(localctx, 2)
                self.state = 316
                self.unwindSt()
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 3)
                self.state = 317
                self.queryCallSt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpdatingStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def createSt(self):
            return self.getTypedRuleContext(CypherParser.CreateStContext,0)


        def mergeSt(self):
            return self.getTypedRuleContext(CypherParser.MergeStContext,0)


        def deleteSt(self):
            return self.getTypedRuleContext(CypherParser.DeleteStContext,0)


        def setSt(self):
            return self.getTypedRuleContext(CypherParser.SetStContext,0)


        def removeSt(self):
            return self.getTypedRuleContext(CypherParser.RemoveStContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_updatingStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdatingStatement" ):
                listener.enterUpdatingStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdatingStatement" ):
                listener.exitUpdatingStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdatingStatement" ):
                return visitor.visitUpdatingStatement(self)
            else:
                return visitor.visitChildren(self)




    def updatingStatement(self):

        localctx = CypherParser.UpdatingStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_updatingStatement)
        try:
            self.state = 325
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [40]:
                self.enterOuterAlt(localctx, 1)
                self.state = 320
                self.createSt()
                pass
            elif token in [48]:
                self.enterOuterAlt(localctx, 2)
                self.state = 321
                self.mergeSt()
                pass
            elif token in [41, 44]:
                self.enterOuterAlt(localctx, 3)
                self.state = 322
                self.deleteSt()
                pass
            elif token in [54]:
                self.enterOuterAlt(localctx, 4)
                self.state = 323
                self.setSt()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 5)
                self.state = 324
                self.removeSt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeleteStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELETE(self):
            return self.getToken(CypherParser.DELETE, 0)

        def expressionChain(self):
            return self.getTypedRuleContext(CypherParser.ExpressionChainContext,0)


        def DETACH(self):
            return self.getToken(CypherParser.DETACH, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_deleteSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeleteSt" ):
                listener.enterDeleteSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeleteSt" ):
                listener.exitDeleteSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeleteSt" ):
                return visitor.visitDeleteSt(self)
            else:
                return visitor.visitChildren(self)




    def deleteSt(self):

        localctx = CypherParser.DeleteStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_deleteSt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==44:
                self.state = 327
                self.match(CypherParser.DETACH)


            self.state = 330
            self.match(CypherParser.DELETE)
            self.state = 331
            self.expressionChain()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RemoveStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REMOVE(self):
            return self.getToken(CypherParser.REMOVE, 0)

        def removeItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.RemoveItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.RemoveItemContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.COMMA)
            else:
                return self.getToken(CypherParser.COMMA, i)

        def getRuleIndex(self):
            return CypherParser.RULE_removeSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemoveSt" ):
                listener.enterRemoveSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemoveSt" ):
                listener.exitRemoveSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRemoveSt" ):
                return visitor.visitRemoveSt(self)
            else:
                return visitor.visitChildren(self)




    def removeSt(self):

        localctx = CypherParser.RemoveStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_removeSt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 333
            self.match(CypherParser.REMOVE)
            self.state = 334
            self.removeItem()
            self.state = 339
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 335
                self.match(CypherParser.COMMA)
                self.state = 336
                self.removeItem()
                self.state = 341
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RemoveItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol(self):
            return self.getTypedRuleContext(CypherParser.SymbolContext,0)


        def nodeLabels(self):
            return self.getTypedRuleContext(CypherParser.NodeLabelsContext,0)


        def propertyExpression(self):
            return self.getTypedRuleContext(CypherParser.PropertyExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_removeItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemoveItem" ):
                listener.enterRemoveItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemoveItem" ):
                listener.exitRemoveItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRemoveItem" ):
                return visitor.visitRemoveItem(self)
            else:
                return visitor.visitChildren(self)




    def removeItem(self):

        localctx = CypherParser.RemoveItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_removeItem)
        try:
            self.state = 346
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 342
                self.symbol()
                self.state = 343
                self.nodeLabels()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 345
                self.propertyExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryCallStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CALL(self):
            return self.getToken(CypherParser.CALL, 0)

        def invocationName(self):
            return self.getTypedRuleContext(CypherParser.InvocationNameContext,0)


        def parenExpressionChain(self):
            return self.getTypedRuleContext(CypherParser.ParenExpressionChainContext,0)


        def YIELD(self):
            return self.getToken(CypherParser.YIELD, 0)

        def yieldItems(self):
            return self.getTypedRuleContext(CypherParser.YieldItemsContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_queryCallSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryCallSt" ):
                listener.enterQueryCallSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryCallSt" ):
                listener.exitQueryCallSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueryCallSt" ):
                return visitor.visitQueryCallSt(self)
            else:
                return visitor.visitChildren(self)




    def queryCallSt(self):

        localctx = CypherParser.QueryCallStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_queryCallSt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 348
            self.match(CypherParser.CALL)
            self.state = 349
            self.invocationName()
            self.state = 350
            self.parenExpressionChain()
            self.state = 353
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==29:
                self.state = 351
                self.match(CypherParser.YIELD)
                self.state = 352
                self.yieldItems()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParenExpressionChainContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(CypherParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(CypherParser.RPAREN, 0)

        def expressionChain(self):
            return self.getTypedRuleContext(CypherParser.ExpressionChainContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_parenExpressionChain

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenExpressionChain" ):
                listener.enterParenExpressionChain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenExpressionChain" ):
                listener.exitParenExpressionChain(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenExpressionChain" ):
                return visitor.visitParenExpressionChain(self)
            else:
                return visitor.visitChildren(self)




    def parenExpressionChain(self):

        localctx = CypherParser.ParenExpressionChainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_parenExpressionChain)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 355
            self.match(CypherParser.LPAREN)
            self.state = 357
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 35320872390656) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 130027633) != 0):
                self.state = 356
                self.expressionChain()


            self.state = 359
            self.match(CypherParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YieldItemsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def yieldItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.YieldItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.YieldItemContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.COMMA)
            else:
                return self.getToken(CypherParser.COMMA, i)

        def where(self):
            return self.getTypedRuleContext(CypherParser.WhereContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_yieldItems

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYieldItems" ):
                listener.enterYieldItems(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYieldItems" ):
                listener.exitYieldItems(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYieldItems" ):
                return visitor.visitYieldItems(self)
            else:
                return visitor.visitChildren(self)




    def yieldItems(self):

        localctx = CypherParser.YieldItemsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_yieldItems)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 361
            self.yieldItem()
            self.state = 366
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 362
                self.match(CypherParser.COMMA)
                self.state = 363
                self.yieldItem()
                self.state = 368
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 370
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==56:
                self.state = 369
                self.where()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YieldItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.SymbolContext)
            else:
                return self.getTypedRuleContext(CypherParser.SymbolContext,i)


        def AS(self):
            return self.getToken(CypherParser.AS, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_yieldItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYieldItem" ):
                listener.enterYieldItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYieldItem" ):
                listener.exitYieldItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYieldItem" ):
                return visitor.visitYieldItem(self)
            else:
                return visitor.visitChildren(self)




    def yieldItem(self):

        localctx = CypherParser.YieldItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_yieldItem)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 375
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.state = 372
                self.symbol()
                self.state = 373
                self.match(CypherParser.AS)


            self.state = 377
            self.symbol()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MergeStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MERGE(self):
            return self.getToken(CypherParser.MERGE, 0)

        def patternPart(self):
            return self.getTypedRuleContext(CypherParser.PatternPartContext,0)


        def mergeAction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.MergeActionContext)
            else:
                return self.getTypedRuleContext(CypherParser.MergeActionContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_mergeSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMergeSt" ):
                listener.enterMergeSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMergeSt" ):
                listener.exitMergeSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMergeSt" ):
                return visitor.visitMergeSt(self)
            else:
                return visitor.visitChildren(self)




    def mergeSt(self):

        localctx = CypherParser.MergeStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_mergeSt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 379
            self.match(CypherParser.MERGE)
            self.state = 380
            self.patternPart()
            self.state = 384
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==49:
                self.state = 381
                self.mergeAction()
                self.state = 386
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MergeActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON(self):
            return self.getToken(CypherParser.ON, 0)

        def setSt(self):
            return self.getTypedRuleContext(CypherParser.SetStContext,0)


        def MATCH(self):
            return self.getToken(CypherParser.MATCH, 0)

        def CREATE(self):
            return self.getToken(CypherParser.CREATE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_mergeAction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMergeAction" ):
                listener.enterMergeAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMergeAction" ):
                listener.exitMergeAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMergeAction" ):
                return visitor.visitMergeAction(self)
            else:
                return visitor.visitChildren(self)




    def mergeAction(self):

        localctx = CypherParser.MergeActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_mergeAction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 387
            self.match(CypherParser.ON)
            self.state = 388
            _la = self._input.LA(1)
            if not(_la==40 or _la==47):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 389
            self.setSt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(CypherParser.SET, 0)

        def setItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.SetItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.SetItemContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.COMMA)
            else:
                return self.getToken(CypherParser.COMMA, i)

        def getRuleIndex(self):
            return CypherParser.RULE_setSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetSt" ):
                listener.enterSetSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetSt" ):
                listener.exitSetSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetSt" ):
                return visitor.visitSetSt(self)
            else:
                return visitor.visitChildren(self)




    def setSt(self):

        localctx = CypherParser.SetStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_setSt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 391
            self.match(CypherParser.SET)
            self.state = 392
            self.setItem()
            self.state = 397
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 393
                self.match(CypherParser.COMMA)
                self.state = 394
                self.setItem()
                self.state = 399
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyExpression(self):
            return self.getTypedRuleContext(CypherParser.PropertyExpressionContext,0)


        def ASSIGN(self):
            return self.getToken(CypherParser.ASSIGN, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def symbol(self):
            return self.getTypedRuleContext(CypherParser.SymbolContext,0)


        def ADD_ASSIGN(self):
            return self.getToken(CypherParser.ADD_ASSIGN, 0)

        def nodeLabels(self):
            return self.getTypedRuleContext(CypherParser.NodeLabelsContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_setItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetItem" ):
                listener.enterSetItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetItem" ):
                listener.exitSetItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetItem" ):
                return visitor.visitSetItem(self)
            else:
                return visitor.visitChildren(self)




    def setItem(self):

        localctx = CypherParser.SetItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_setItem)
        self._la = 0 # Token type
        try:
            self.state = 411
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 400
                self.propertyExpression()
                self.state = 401
                self.match(CypherParser.ASSIGN)
                self.state = 402
                self.expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 404
                self.symbol()
                self.state = 405
                _la = self._input.LA(1)
                if not(_la==1 or _la==2):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 406
                self.expression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 408
                self.symbol()
                self.state = 409
                self.nodeLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodeLabelsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.COLON)
            else:
                return self.getToken(CypherParser.COLON, i)

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.NameContext)
            else:
                return self.getTypedRuleContext(CypherParser.NameContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_nodeLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodeLabels" ):
                listener.enterNodeLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodeLabels" ):
                listener.exitNodeLabels(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodeLabels" ):
                return visitor.visitNodeLabels(self)
            else:
                return visitor.visitChildren(self)




    def nodeLabels(self):

        localctx = CypherParser.NodeLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_nodeLabels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 415 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 413
                self.match(CypherParser.COLON)
                self.state = 414
                self.name()
                self.state = 417 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==25):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE(self):
            return self.getToken(CypherParser.CREATE, 0)

        def pattern(self):
            return self.getTypedRuleContext(CypherParser.PatternContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_createSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreateSt" ):
                listener.enterCreateSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreateSt" ):
                listener.exitCreateSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateSt" ):
                return visitor.visitCreateSt(self)
            else:
                return visitor.visitChildren(self)




    def createSt(self):

        localctx = CypherParser.CreateStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_createSt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 419
            self.match(CypherParser.CREATE)
            self.state = 420
            self.pattern()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternWhereContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pattern(self):
            return self.getTypedRuleContext(CypherParser.PatternContext,0)


        def where(self):
            return self.getTypedRuleContext(CypherParser.WhereContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_patternWhere

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternWhere" ):
                listener.enterPatternWhere(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternWhere" ):
                listener.exitPatternWhere(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternWhere" ):
                return visitor.visitPatternWhere(self)
            else:
                return visitor.visitChildren(self)




    def patternWhere(self):

        localctx = CypherParser.PatternWhereContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_patternWhere)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 422
            self.pattern()
            self.state = 424
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==56:
                self.state = 423
                self.where()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhereContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(CypherParser.WHERE, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_where

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhere" ):
                listener.enterWhere(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhere" ):
                listener.exitWhere(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhere" ):
                return visitor.visitWhere(self)
            else:
                return visitor.visitChildren(self)




    def where(self):

        localctx = CypherParser.WhereContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_where)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 426
            self.match(CypherParser.WHERE)
            self.state = 427
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def patternPart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PatternPartContext)
            else:
                return self.getTypedRuleContext(CypherParser.PatternPartContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.COMMA)
            else:
                return self.getToken(CypherParser.COMMA, i)

        def getRuleIndex(self):
            return CypherParser.RULE_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern" ):
                listener.enterPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern" ):
                listener.exitPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPattern" ):
                return visitor.visitPattern(self)
            else:
                return visitor.visitChildren(self)




    def pattern(self):

        localctx = CypherParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_pattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 429
            self.patternPart()
            self.state = 434
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 430
                self.match(CypherParser.COMMA)
                self.state = 431
                self.patternPart()
                self.state = 436
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xorExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.XorExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.XorExpressionContext,i)


        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.OR)
            else:
                return self.getToken(CypherParser.OR, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = CypherParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 437
            self.xorExpression()
            self.state = 442
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==68:
                self.state = 438
                self.match(CypherParser.OR)
                self.state = 439
                self.xorExpression()
                self.state = 444
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XorExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def andExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.AndExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.AndExpressionContext,i)


        def XOR(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.XOR)
            else:
                return self.getToken(CypherParser.XOR, i)

        def getRuleIndex(self):
            return CypherParser.RULE_xorExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXorExpression" ):
                listener.enterXorExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXorExpression" ):
                listener.exitXorExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXorExpression" ):
                return visitor.visitXorExpression(self)
            else:
                return visitor.visitChildren(self)




    def xorExpression(self):

        localctx = CypherParser.XorExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_xorExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 445
            self.andExpression()
            self.state = 450
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==70:
                self.state = 446
                self.match(CypherParser.XOR)
                self.state = 447
                self.andExpression()
                self.state = 452
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AndExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def notExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.NotExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.NotExpressionContext,i)


        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.AND)
            else:
                return self.getToken(CypherParser.AND, i)

        def getRuleIndex(self):
            return CypherParser.RULE_andExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAndExpression" ):
                listener.enterAndExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAndExpression" ):
                listener.exitAndExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAndExpression" ):
                return visitor.visitAndExpression(self)
            else:
                return visitor.visitChildren(self)




    def andExpression(self):

        localctx = CypherParser.AndExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_andExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 453
            self.notExpression()
            self.state = 458
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==60:
                self.state = 454
                self.match(CypherParser.AND)
                self.state = 455
                self.notExpression()
                self.state = 460
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NotExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparisonExpression(self):
            return self.getTypedRuleContext(CypherParser.ComparisonExpressionContext,0)


        def NOT(self):
            return self.getToken(CypherParser.NOT, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_notExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotExpression" ):
                listener.enterNotExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotExpression" ):
                listener.exitNotExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotExpression" ):
                return visitor.visitNotExpression(self)
            else:
                return visitor.visitChildren(self)




    def notExpression(self):

        localctx = CypherParser.NotExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_notExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 462
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==67:
                self.state = 461
                self.match(CypherParser.NOT)


            self.state = 464
            self.comparisonExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def addSubExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.AddSubExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.AddSubExpressionContext,i)


        def comparisonSigns(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ComparisonSignsContext)
            else:
                return self.getTypedRuleContext(CypherParser.ComparisonSignsContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_comparisonExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonExpression" ):
                listener.enterComparisonExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonExpression" ):
                listener.exitComparisonExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonExpression" ):
                return visitor.visitComparisonExpression(self)
            else:
                return visitor.visitChildren(self)




    def comparisonExpression(self):

        localctx = CypherParser.ComparisonExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_comparisonExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 466
            self.addSubExpression()
            self.state = 472
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 250) != 0):
                self.state = 467
                self.comparisonSigns()
                self.state = 468
                self.addSubExpression()
                self.state = 474
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonSignsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSIGN(self):
            return self.getToken(CypherParser.ASSIGN, 0)

        def LE(self):
            return self.getToken(CypherParser.LE, 0)

        def GE(self):
            return self.getToken(CypherParser.GE, 0)

        def GT(self):
            return self.getToken(CypherParser.GT, 0)

        def LT(self):
            return self.getToken(CypherParser.LT, 0)

        def NOT_EQUAL(self):
            return self.getToken(CypherParser.NOT_EQUAL, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_comparisonSigns

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonSigns" ):
                listener.enterComparisonSigns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonSigns" ):
                listener.exitComparisonSigns(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonSigns" ):
                return visitor.visitComparisonSigns(self)
            else:
                return visitor.visitChildren(self)




    def comparisonSigns(self):

        localctx = CypherParser.ComparisonSignsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_comparisonSigns)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 475
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 250) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddSubExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multDivExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.MultDivExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.MultDivExpressionContext,i)


        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.PLUS)
            else:
                return self.getToken(CypherParser.PLUS, i)

        def SUB(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SUB)
            else:
                return self.getToken(CypherParser.SUB, i)

        def getRuleIndex(self):
            return CypherParser.RULE_addSubExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddSubExpression" ):
                listener.enterAddSubExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddSubExpression" ):
                listener.exitAddSubExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddSubExpression" ):
                return visitor.visitAddSubExpression(self)
            else:
                return visitor.visitChildren(self)




    def addSubExpression(self):

        localctx = CypherParser.AddSubExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_addSubExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 477
            self.multDivExpression()
            self.state = 482
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18 or _la==19:
                self.state = 478
                _la = self._input.LA(1)
                if not(_la==18 or _la==19):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 479
                self.multDivExpression()
                self.state = 484
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultDivExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def powerExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PowerExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.PowerExpressionContext,i)


        def MULT(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.MULT)
            else:
                return self.getToken(CypherParser.MULT, i)

        def DIV(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.DIV)
            else:
                return self.getToken(CypherParser.DIV, i)

        def MOD(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.MOD)
            else:
                return self.getToken(CypherParser.MOD, i)

        def getRuleIndex(self):
            return CypherParser.RULE_multDivExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultDivExpression" ):
                listener.enterMultDivExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultDivExpression" ):
                listener.exitMultDivExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultDivExpression" ):
                return visitor.visitMultDivExpression(self)
            else:
                return visitor.visitChildren(self)




    def multDivExpression(self):

        localctx = CypherParser.MultDivExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_multDivExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 485
            self.powerExpression()
            self.state = 490
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 11534336) != 0):
                self.state = 486
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 11534336) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 487
                self.powerExpression()
                self.state = 492
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unaryAddSubExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.UnaryAddSubExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.UnaryAddSubExpressionContext,i)


        def CARET(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.CARET)
            else:
                return self.getToken(CypherParser.CARET, i)

        def getRuleIndex(self):
            return CypherParser.RULE_powerExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerExpression" ):
                listener.enterPowerExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerExpression" ):
                listener.exitPowerExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerExpression" ):
                return visitor.visitPowerExpression(self)
            else:
                return visitor.visitChildren(self)




    def powerExpression(self):

        localctx = CypherParser.PowerExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_powerExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 493
            self.unaryAddSubExpression()
            self.state = 498
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==22:
                self.state = 494
                self.match(CypherParser.CARET)
                self.state = 495
                self.unaryAddSubExpression()
                self.state = 500
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryAddSubExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomicExpression(self):
            return self.getTypedRuleContext(CypherParser.AtomicExpressionContext,0)


        def PLUS(self):
            return self.getToken(CypherParser.PLUS, 0)

        def SUB(self):
            return self.getToken(CypherParser.SUB, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_unaryAddSubExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryAddSubExpression" ):
                listener.enterUnaryAddSubExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryAddSubExpression" ):
                listener.exitUnaryAddSubExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryAddSubExpression" ):
                return visitor.visitUnaryAddSubExpression(self)
            else:
                return visitor.visitChildren(self)




    def unaryAddSubExpression(self):

        localctx = CypherParser.UnaryAddSubExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_unaryAddSubExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 502
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==18 or _la==19:
                self.state = 501
                _la = self._input.LA(1)
                if not(_la==18 or _la==19):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 504
            self.atomicExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomicExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyOrLabelExpression(self):
            return self.getTypedRuleContext(CypherParser.PropertyOrLabelExpressionContext,0)


        def stringExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.StringExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.StringExpressionContext,i)


        def listExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ListExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ListExpressionContext,i)


        def nullExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.NullExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.NullExpressionContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_atomicExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomicExpression" ):
                listener.enterAtomicExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomicExpression" ):
                listener.exitAtomicExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomicExpression" ):
                return visitor.visitAtomicExpression(self)
            else:
                return visitor.visitChildren(self)




    def atomicExpression(self):

        localctx = CypherParser.AtomicExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_atomicExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 506
            self.propertyOrLabelExpression()
            self.state = 512
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 16)) & ~0x3f) == 0 and ((1 << (_la - 16)) & 11047892835893249) != 0):
                self.state = 510
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [62, 64, 69]:
                    self.state = 507
                    self.stringExpression()
                    pass
                elif token in [16, 65]:
                    self.state = 508
                    self.listExpression()
                    pass
                elif token in [66]:
                    self.state = 509
                    self.nullExpression()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 514
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ListExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN(self):
            return self.getToken(CypherParser.IN, 0)

        def propertyOrLabelExpression(self):
            return self.getTypedRuleContext(CypherParser.PropertyOrLabelExpressionContext,0)


        def LBRACK(self):
            return self.getToken(CypherParser.LBRACK, 0)

        def RBRACK(self):
            return self.getToken(CypherParser.RBRACK, 0)

        def RANGE(self):
            return self.getToken(CypherParser.RANGE, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_listExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListExpression" ):
                listener.enterListExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListExpression" ):
                listener.exitListExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListExpression" ):
                return visitor.visitListExpression(self)
            else:
                return visitor.visitChildren(self)




    def listExpression(self):

        localctx = CypherParser.ListExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_listExpression)
        self._la = 0 # Token type
        try:
            self.state = 529
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [65]:
                self.enterOuterAlt(localctx, 1)
                self.state = 515
                self.match(CypherParser.IN)
                self.state = 516
                self.propertyOrLabelExpression()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 517
                self.match(CypherParser.LBRACK)
                self.state = 526
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
                if la_ == 1:
                    self.state = 519
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & 35320872390656) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 130027633) != 0):
                        self.state = 518
                        self.expression()


                    self.state = 521
                    self.match(CypherParser.RANGE)
                    self.state = 523
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & 35320872390656) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 130027633) != 0):
                        self.state = 522
                        self.expression()


                    pass

                elif la_ == 2:
                    self.state = 525
                    self.expression()
                    pass


                self.state = 528
                self.match(CypherParser.RBRACK)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringExpPrefix(self):
            return self.getTypedRuleContext(CypherParser.StringExpPrefixContext,0)


        def propertyOrLabelExpression(self):
            return self.getTypedRuleContext(CypherParser.PropertyOrLabelExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_stringExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringExpression" ):
                listener.enterStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringExpression" ):
                listener.exitStringExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringExpression" ):
                return visitor.visitStringExpression(self)
            else:
                return visitor.visitChildren(self)




    def stringExpression(self):

        localctx = CypherParser.StringExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_stringExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 531
            self.stringExpPrefix()
            self.state = 532
            self.propertyOrLabelExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringExpPrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STARTS(self):
            return self.getToken(CypherParser.STARTS, 0)

        def WITH(self):
            return self.getToken(CypherParser.WITH, 0)

        def ENDS(self):
            return self.getToken(CypherParser.ENDS, 0)

        def CONTAINS(self):
            return self.getToken(CypherParser.CONTAINS, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_stringExpPrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringExpPrefix" ):
                listener.enterStringExpPrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringExpPrefix" ):
                listener.exitStringExpPrefix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringExpPrefix" ):
                return visitor.visitStringExpPrefix(self)
            else:
                return visitor.visitChildren(self)




    def stringExpPrefix(self):

        localctx = CypherParser.StringExpPrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_stringExpPrefix)
        try:
            self.state = 539
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [69]:
                self.enterOuterAlt(localctx, 1)
                self.state = 534
                self.match(CypherParser.STARTS)
                self.state = 535
                self.match(CypherParser.WITH)
                pass
            elif token in [64]:
                self.enterOuterAlt(localctx, 2)
                self.state = 536
                self.match(CypherParser.ENDS)
                self.state = 537
                self.match(CypherParser.WITH)
                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 3)
                self.state = 538
                self.match(CypherParser.CONTAINS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NullExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IS(self):
            return self.getToken(CypherParser.IS, 0)

        def NULL_W(self):
            return self.getToken(CypherParser.NULL_W, 0)

        def NOT(self):
            return self.getToken(CypherParser.NOT, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_nullExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNullExpression" ):
                listener.enterNullExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNullExpression" ):
                listener.exitNullExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNullExpression" ):
                return visitor.visitNullExpression(self)
            else:
                return visitor.visitChildren(self)




    def nullExpression(self):

        localctx = CypherParser.NullExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_nullExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 541
            self.match(CypherParser.IS)
            self.state = 543
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==67:
                self.state = 542
                self.match(CypherParser.NOT)


            self.state = 545
            self.match(CypherParser.NULL_W)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyOrLabelExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyExpression(self):
            return self.getTypedRuleContext(CypherParser.PropertyExpressionContext,0)


        def nodeLabels(self):
            return self.getTypedRuleContext(CypherParser.NodeLabelsContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_propertyOrLabelExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyOrLabelExpression" ):
                listener.enterPropertyOrLabelExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyOrLabelExpression" ):
                listener.exitPropertyOrLabelExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyOrLabelExpression" ):
                return visitor.visitPropertyOrLabelExpression(self)
            else:
                return visitor.visitChildren(self)




    def propertyOrLabelExpression(self):

        localctx = CypherParser.PropertyOrLabelExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_propertyOrLabelExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 547
            self.propertyExpression()
            self.state = 549
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==25:
                self.state = 548
                self.nodeLabels()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(CypherParser.AtomContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.DOT)
            else:
                return self.getToken(CypherParser.DOT, i)

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.NameContext)
            else:
                return self.getTypedRuleContext(CypherParser.NameContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_propertyExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyExpression" ):
                listener.enterPropertyExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyExpression" ):
                listener.exitPropertyExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyExpression" ):
                return visitor.visitPropertyExpression(self)
            else:
                return visitor.visitChildren(self)




    def propertyExpression(self):

        localctx = CypherParser.PropertyExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_propertyExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 551
            self.atom()
            self.state = 556
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 552
                self.match(CypherParser.DOT)
                self.state = 553
                self.name()
                self.state = 558
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def patternElem(self):
            return self.getTypedRuleContext(CypherParser.PatternElemContext,0)


        def symbol(self):
            return self.getTypedRuleContext(CypherParser.SymbolContext,0)


        def ASSIGN(self):
            return self.getToken(CypherParser.ASSIGN, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_patternPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternPart" ):
                listener.enterPatternPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternPart" ):
                listener.exitPatternPart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternPart" ):
                return visitor.visitPatternPart(self)
            else:
                return visitor.visitChildren(self)




    def patternPart(self):

        localctx = CypherParser.PatternPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_patternPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 562
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 30)) & ~0x3f) == 0 and ((1 << (_la - 30)) & 1729382256910270527) != 0):
                self.state = 559
                self.symbol()
                self.state = 560
                self.match(CypherParser.ASSIGN)


            self.state = 564
            self.patternElem()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternElemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodePattern(self):
            return self.getTypedRuleContext(CypherParser.NodePatternContext,0)


        def patternElemChain(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PatternElemChainContext)
            else:
                return self.getTypedRuleContext(CypherParser.PatternElemChainContext,i)


        def LPAREN(self):
            return self.getToken(CypherParser.LPAREN, 0)

        def patternElem(self):
            return self.getTypedRuleContext(CypherParser.PatternElemContext,0)


        def RPAREN(self):
            return self.getToken(CypherParser.RPAREN, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_patternElem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternElem" ):
                listener.enterPatternElem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternElem" ):
                listener.exitPatternElem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternElem" ):
                return visitor.visitPatternElem(self)
            else:
                return visitor.visitChildren(self)




    def patternElem(self):

        localctx = CypherParser.PatternElemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_patternElem)
        self._la = 0 # Token type
        try:
            self.state = 577
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 566
                self.nodePattern()
                self.state = 570
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==6 or _la==18:
                    self.state = 567
                    self.patternElemChain()
                    self.state = 572
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 573
                self.match(CypherParser.LPAREN)
                self.state = 574
                self.patternElem()
                self.state = 575
                self.match(CypherParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternElemChainContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relationshipPattern(self):
            return self.getTypedRuleContext(CypherParser.RelationshipPatternContext,0)


        def nodePattern(self):
            return self.getTypedRuleContext(CypherParser.NodePatternContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_patternElemChain

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternElemChain" ):
                listener.enterPatternElemChain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternElemChain" ):
                listener.exitPatternElemChain(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternElemChain" ):
                return visitor.visitPatternElemChain(self)
            else:
                return visitor.visitChildren(self)




    def patternElemChain(self):

        localctx = CypherParser.PatternElemChainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_patternElemChain)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 579
            self.relationshipPattern()
            self.state = 580
            self.nodePattern()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mapLit(self):
            return self.getTypedRuleContext(CypherParser.MapLitContext,0)


        def parameter(self):
            return self.getTypedRuleContext(CypherParser.ParameterContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_properties

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProperties" ):
                listener.enterProperties(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProperties" ):
                listener.exitProperties(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProperties" ):
                return visitor.visitProperties(self)
            else:
                return visitor.visitChildren(self)




    def properties(self):

        localctx = CypherParser.PropertiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_properties)
        try:
            self.state = 584
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [14]:
                self.enterOuterAlt(localctx, 1)
                self.state = 582
                self.mapLit()
                pass
            elif token in [27]:
                self.enterOuterAlt(localctx, 2)
                self.state = 583
                self.parameter()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodePatternContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(CypherParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(CypherParser.RPAREN, 0)

        def symbol(self):
            return self.getTypedRuleContext(CypherParser.SymbolContext,0)


        def nodeLabels(self):
            return self.getTypedRuleContext(CypherParser.NodeLabelsContext,0)


        def properties(self):
            return self.getTypedRuleContext(CypherParser.PropertiesContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_nodePattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodePattern" ):
                listener.enterNodePattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodePattern" ):
                listener.exitNodePattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodePattern" ):
                return visitor.visitNodePattern(self)
            else:
                return visitor.visitChildren(self)




    def nodePattern(self):

        localctx = CypherParser.NodePatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_nodePattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 586
            self.match(CypherParser.LPAREN)
            self.state = 588
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 30)) & ~0x3f) == 0 and ((1 << (_la - 30)) & 1729382256910270527) != 0):
                self.state = 587
                self.symbol()


            self.state = 591
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==25:
                self.state = 590
                self.nodeLabels()


            self.state = 594
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14 or _la==27:
                self.state = 593
                self.properties()


            self.state = 596
            self.match(CypherParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(CypherParser.LiteralContext,0)


        def parameter(self):
            return self.getTypedRuleContext(CypherParser.ParameterContext,0)


        def caseExpression(self):
            return self.getTypedRuleContext(CypherParser.CaseExpressionContext,0)


        def countAll(self):
            return self.getTypedRuleContext(CypherParser.CountAllContext,0)


        def listComprehension(self):
            return self.getTypedRuleContext(CypherParser.ListComprehensionContext,0)


        def patternComprehension(self):
            return self.getTypedRuleContext(CypherParser.PatternComprehensionContext,0)


        def filterWith(self):
            return self.getTypedRuleContext(CypherParser.FilterWithContext,0)


        def relationshipsChainPattern(self):
            return self.getTypedRuleContext(CypherParser.RelationshipsChainPatternContext,0)


        def parenthesizedExpression(self):
            return self.getTypedRuleContext(CypherParser.ParenthesizedExpressionContext,0)


        def functionInvocation(self):
            return self.getTypedRuleContext(CypherParser.FunctionInvocationContext,0)


        def symbol(self):
            return self.getTypedRuleContext(CypherParser.SymbolContext,0)


        def subqueryExist(self):
            return self.getTypedRuleContext(CypherParser.SubqueryExistContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtom" ):
                return visitor.visitAtom(self)
            else:
                return visitor.visitChildren(self)




    def atom(self):

        localctx = CypherParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_atom)
        try:
            self.state = 610
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 598
                self.literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 599
                self.parameter()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 600
                self.caseExpression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 601
                self.countAll()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 602
                self.listComprehension()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 603
                self.patternComprehension()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 604
                self.filterWith()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 605
                self.relationshipsChainPattern()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 606
                self.parenthesizedExpression()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 607
                self.functionInvocation()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 608
                self.symbol()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 609
                self.subqueryExist()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LhsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol(self):
            return self.getTypedRuleContext(CypherParser.SymbolContext,0)


        def ASSIGN(self):
            return self.getToken(CypherParser.ASSIGN, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_lhs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLhs" ):
                listener.enterLhs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLhs" ):
                listener.exitLhs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLhs" ):
                return visitor.visitLhs(self)
            else:
                return visitor.visitChildren(self)




    def lhs(self):

        localctx = CypherParser.LhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_lhs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 612
            self.symbol()
            self.state = 613
            self.match(CypherParser.ASSIGN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationshipPatternContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(CypherParser.LT, 0)

        def SUB(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SUB)
            else:
                return self.getToken(CypherParser.SUB, i)

        def relationDetail(self):
            return self.getTypedRuleContext(CypherParser.RelationDetailContext,0)


        def GT(self):
            return self.getToken(CypherParser.GT, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_relationshipPattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipPattern" ):
                listener.enterRelationshipPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipPattern" ):
                listener.exitRelationshipPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationshipPattern" ):
                return visitor.visitRelationshipPattern(self)
            else:
                return visitor.visitChildren(self)




    def relationshipPattern(self):

        localctx = CypherParser.RelationshipPatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_relationshipPattern)
        self._la = 0 # Token type
        try:
            self.state = 632
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 615
                self.match(CypherParser.LT)
                self.state = 616
                self.match(CypherParser.SUB)
                self.state = 618
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==16:
                    self.state = 617
                    self.relationDetail()


                self.state = 620
                self.match(CypherParser.SUB)
                self.state = 622
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==5:
                    self.state = 621
                    self.match(CypherParser.GT)


                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 624
                self.match(CypherParser.SUB)
                self.state = 626
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==16:
                    self.state = 625
                    self.relationDetail()


                self.state = 628
                self.match(CypherParser.SUB)
                self.state = 630
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==5:
                    self.state = 629
                    self.match(CypherParser.GT)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationDetailContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACK(self):
            return self.getToken(CypherParser.LBRACK, 0)

        def RBRACK(self):
            return self.getToken(CypherParser.RBRACK, 0)

        def symbol(self):
            return self.getTypedRuleContext(CypherParser.SymbolContext,0)


        def relationshipTypes(self):
            return self.getTypedRuleContext(CypherParser.RelationshipTypesContext,0)


        def rangeLit(self):
            return self.getTypedRuleContext(CypherParser.RangeLitContext,0)


        def properties(self):
            return self.getTypedRuleContext(CypherParser.PropertiesContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_relationDetail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationDetail" ):
                listener.enterRelationDetail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationDetail" ):
                listener.exitRelationDetail(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationDetail" ):
                return visitor.visitRelationDetail(self)
            else:
                return visitor.visitChildren(self)




    def relationDetail(self):

        localctx = CypherParser.RelationDetailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_relationDetail)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 634
            self.match(CypherParser.LBRACK)
            self.state = 636
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 30)) & ~0x3f) == 0 and ((1 << (_la - 30)) & 1729382256910270527) != 0):
                self.state = 635
                self.symbol()


            self.state = 639
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==25:
                self.state = 638
                self.relationshipTypes()


            self.state = 642
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==23:
                self.state = 641
                self.rangeLit()


            self.state = 645
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14 or _la==27:
                self.state = 644
                self.properties()


            self.state = 647
            self.match(CypherParser.RBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationshipTypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.COLON)
            else:
                return self.getToken(CypherParser.COLON, i)

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.NameContext)
            else:
                return self.getTypedRuleContext(CypherParser.NameContext,i)


        def STICK(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.STICK)
            else:
                return self.getToken(CypherParser.STICK, i)

        def getRuleIndex(self):
            return CypherParser.RULE_relationshipTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipTypes" ):
                listener.enterRelationshipTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipTypes" ):
                listener.exitRelationshipTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationshipTypes" ):
                return visitor.visitRelationshipTypes(self)
            else:
                return visitor.visitChildren(self)




    def relationshipTypes(self):

        localctx = CypherParser.RelationshipTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_relationshipTypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 649
            self.match(CypherParser.COLON)
            self.state = 650
            self.name()
            self.state = 658
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==26:
                self.state = 651
                self.match(CypherParser.STICK)
                self.state = 653
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==25:
                    self.state = 652
                    self.match(CypherParser.COLON)


                self.state = 655
                self.name()
                self.state = 660
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnionStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNION(self):
            return self.getToken(CypherParser.UNION, 0)

        def singleQuery(self):
            return self.getTypedRuleContext(CypherParser.SingleQueryContext,0)


        def ALL(self):
            return self.getToken(CypherParser.ALL, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_unionSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnionSt" ):
                listener.enterUnionSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnionSt" ):
                listener.exitUnionSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnionSt" ):
                return visitor.visitUnionSt(self)
            else:
                return visitor.visitChildren(self)




    def unionSt(self):

        localctx = CypherParser.UnionStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_unionSt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 661
            self.match(CypherParser.UNION)
            self.state = 663
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==36:
                self.state = 662
                self.match(CypherParser.ALL)


            self.state = 665
            self.singleQuery()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubqueryExistContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXISTS(self):
            return self.getToken(CypherParser.EXISTS, 0)

        def LBRACE(self):
            return self.getToken(CypherParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(CypherParser.RBRACE, 0)

        def regularQuery(self):
            return self.getTypedRuleContext(CypherParser.RegularQueryContext,0)


        def patternWhere(self):
            return self.getTypedRuleContext(CypherParser.PatternWhereContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_subqueryExist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubqueryExist" ):
                listener.enterSubqueryExist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubqueryExist" ):
                listener.exitSubqueryExist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubqueryExist" ):
                return visitor.visitSubqueryExist(self)
            else:
                return visitor.visitChildren(self)




    def subqueryExist(self):

        localctx = CypherParser.SubqueryExistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_subqueryExist)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 667
            self.match(CypherParser.EXISTS)
            self.state = 668
            self.match(CypherParser.LBRACE)
            self.state = 671
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [28, 40, 41, 44, 47, 48, 50, 52, 53, 54, 57, 59]:
                self.state = 669
                self.regularQuery()
                pass
            elif token in [12, 30, 31, 32, 33, 34, 35, 89, 90]:
                self.state = 670
                self.patternWhere()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 673
            self.match(CypherParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InvocationNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.SymbolContext)
            else:
                return self.getTypedRuleContext(CypherParser.SymbolContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.DOT)
            else:
                return self.getToken(CypherParser.DOT, i)

        def getRuleIndex(self):
            return CypherParser.RULE_invocationName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInvocationName" ):
                listener.enterInvocationName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInvocationName" ):
                listener.exitInvocationName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInvocationName" ):
                return visitor.visitInvocationName(self)
            else:
                return visitor.visitChildren(self)




    def invocationName(self):

        localctx = CypherParser.InvocationNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_invocationName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 675
            self.symbol()
            self.state = 680
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 676
                self.match(CypherParser.DOT)
                self.state = 677
                self.symbol()
                self.state = 682
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionInvocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def invocationName(self):
            return self.getTypedRuleContext(CypherParser.InvocationNameContext,0)


        def LPAREN(self):
            return self.getToken(CypherParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(CypherParser.RPAREN, 0)

        def DISTINCT(self):
            return self.getToken(CypherParser.DISTINCT, 0)

        def expressionChain(self):
            return self.getTypedRuleContext(CypherParser.ExpressionChainContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_functionInvocation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionInvocation" ):
                listener.enterFunctionInvocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionInvocation" ):
                listener.exitFunctionInvocation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionInvocation" ):
                return visitor.visitFunctionInvocation(self)
            else:
                return visitor.visitChildren(self)




    def functionInvocation(self):

        localctx = CypherParser.FunctionInvocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_functionInvocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 683
            self.invocationName()
            self.state = 684
            self.match(CypherParser.LPAREN)
            self.state = 686
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==63:
                self.state = 685
                self.match(CypherParser.DISTINCT)


            self.state = 689
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 35320872390656) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 130027633) != 0):
                self.state = 688
                self.expressionChain()


            self.state = 691
            self.match(CypherParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParenthesizedExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(CypherParser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def RPAREN(self):
            return self.getToken(CypherParser.RPAREN, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_parenthesizedExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedExpression" ):
                listener.enterParenthesizedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedExpression" ):
                listener.exitParenthesizedExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedExpression" ):
                return visitor.visitParenthesizedExpression(self)
            else:
                return visitor.visitChildren(self)




    def parenthesizedExpression(self):

        localctx = CypherParser.ParenthesizedExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_parenthesizedExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 693
            self.match(CypherParser.LPAREN)
            self.state = 694
            self.expression()
            self.state = 695
            self.match(CypherParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilterWithContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(CypherParser.LPAREN, 0)

        def filterExpression(self):
            return self.getTypedRuleContext(CypherParser.FilterExpressionContext,0)


        def RPAREN(self):
            return self.getToken(CypherParser.RPAREN, 0)

        def ALL(self):
            return self.getToken(CypherParser.ALL, 0)

        def ANY(self):
            return self.getToken(CypherParser.ANY, 0)

        def NONE(self):
            return self.getToken(CypherParser.NONE, 0)

        def SINGLE(self):
            return self.getToken(CypherParser.SINGLE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_filterWith

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilterWith" ):
                listener.enterFilterWith(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilterWith" ):
                listener.exitFilterWith(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilterWith" ):
                return visitor.visitFilterWith(self)
            else:
                return visitor.visitChildren(self)




    def filterWith(self):

        localctx = CypherParser.FilterWithContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_filterWith)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 697
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 128849018880) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 698
            self.match(CypherParser.LPAREN)
            self.state = 699
            self.filterExpression()
            self.state = 700
            self.match(CypherParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternComprehensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACK(self):
            return self.getToken(CypherParser.LBRACK, 0)

        def relationshipsChainPattern(self):
            return self.getTypedRuleContext(CypherParser.RelationshipsChainPatternContext,0)


        def STICK(self):
            return self.getToken(CypherParser.STICK, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def RBRACK(self):
            return self.getToken(CypherParser.RBRACK, 0)

        def lhs(self):
            return self.getTypedRuleContext(CypherParser.LhsContext,0)


        def where(self):
            return self.getTypedRuleContext(CypherParser.WhereContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_patternComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternComprehension" ):
                listener.enterPatternComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternComprehension" ):
                listener.exitPatternComprehension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternComprehension" ):
                return visitor.visitPatternComprehension(self)
            else:
                return visitor.visitChildren(self)




    def patternComprehension(self):

        localctx = CypherParser.PatternComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_patternComprehension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 702
            self.match(CypherParser.LBRACK)
            self.state = 704
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 30)) & ~0x3f) == 0 and ((1 << (_la - 30)) & 1729382256910270527) != 0):
                self.state = 703
                self.lhs()


            self.state = 706
            self.relationshipsChainPattern()
            self.state = 708
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==56:
                self.state = 707
                self.where()


            self.state = 710
            self.match(CypherParser.STICK)
            self.state = 711
            self.expression()
            self.state = 712
            self.match(CypherParser.RBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationshipsChainPatternContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodePattern(self):
            return self.getTypedRuleContext(CypherParser.NodePatternContext,0)


        def patternElemChain(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PatternElemChainContext)
            else:
                return self.getTypedRuleContext(CypherParser.PatternElemChainContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_relationshipsChainPattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipsChainPattern" ):
                listener.enterRelationshipsChainPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipsChainPattern" ):
                listener.exitRelationshipsChainPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationshipsChainPattern" ):
                return visitor.visitRelationshipsChainPattern(self)
            else:
                return visitor.visitChildren(self)




    def relationshipsChainPattern(self):

        localctx = CypherParser.RelationshipsChainPatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_relationshipsChainPattern)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 714
            self.nodePattern()
            self.state = 716 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 715
                    self.patternElemChain()

                else:
                    raise NoViableAltException(self)
                self.state = 718 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,86,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ListComprehensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACK(self):
            return self.getToken(CypherParser.LBRACK, 0)

        def filterExpression(self):
            return self.getTypedRuleContext(CypherParser.FilterExpressionContext,0)


        def RBRACK(self):
            return self.getToken(CypherParser.RBRACK, 0)

        def STICK(self):
            return self.getToken(CypherParser.STICK, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_listComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListComprehension" ):
                listener.enterListComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListComprehension" ):
                listener.exitListComprehension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListComprehension" ):
                return visitor.visitListComprehension(self)
            else:
                return visitor.visitChildren(self)




    def listComprehension(self):

        localctx = CypherParser.ListComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_listComprehension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 720
            self.match(CypherParser.LBRACK)
            self.state = 721
            self.filterExpression()
            self.state = 724
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 722
                self.match(CypherParser.STICK)
                self.state = 723
                self.expression()


            self.state = 726
            self.match(CypherParser.RBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilterExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol(self):
            return self.getTypedRuleContext(CypherParser.SymbolContext,0)


        def IN(self):
            return self.getToken(CypherParser.IN, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def where(self):
            return self.getTypedRuleContext(CypherParser.WhereContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_filterExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilterExpression" ):
                listener.enterFilterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilterExpression" ):
                listener.exitFilterExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilterExpression" ):
                return visitor.visitFilterExpression(self)
            else:
                return visitor.visitChildren(self)




    def filterExpression(self):

        localctx = CypherParser.FilterExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_filterExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 728
            self.symbol()
            self.state = 729
            self.match(CypherParser.IN)
            self.state = 730
            self.expression()
            self.state = 732
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==56:
                self.state = 731
                self.where()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountAllContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COUNT(self):
            return self.getToken(CypherParser.COUNT, 0)

        def LPAREN(self):
            return self.getToken(CypherParser.LPAREN, 0)

        def MULT(self):
            return self.getToken(CypherParser.MULT, 0)

        def RPAREN(self):
            return self.getToken(CypherParser.RPAREN, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_countAll

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCountAll" ):
                listener.enterCountAll(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCountAll" ):
                listener.exitCountAll(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCountAll" ):
                return visitor.visitCountAll(self)
            else:
                return visitor.visitChildren(self)




    def countAll(self):

        localctx = CypherParser.CountAllContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_countAll)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 734
            self.match(CypherParser.COUNT)
            self.state = 735
            self.match(CypherParser.LPAREN)
            self.state = 736
            self.match(CypherParser.MULT)
            self.state = 737
            self.match(CypherParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionChainContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.COMMA)
            else:
                return self.getToken(CypherParser.COMMA, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expressionChain

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionChain" ):
                listener.enterExpressionChain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionChain" ):
                listener.exitExpressionChain(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionChain" ):
                return visitor.visitExpressionChain(self)
            else:
                return visitor.visitChildren(self)




    def expressionChain(self):

        localctx = CypherParser.ExpressionChainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_expressionChain)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 739
            self.expression()
            self.state = 744
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 740
                self.match(CypherParser.COMMA)
                self.state = 741
                self.expression()
                self.state = 746
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(CypherParser.CASE, 0)

        def END(self):
            return self.getToken(CypherParser.END, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def WHEN(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.WHEN)
            else:
                return self.getToken(CypherParser.WHEN, i)

        def THEN(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.THEN)
            else:
                return self.getToken(CypherParser.THEN, i)

        def ELSE(self):
            return self.getToken(CypherParser.ELSE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_caseExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseExpression" ):
                listener.enterCaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseExpression" ):
                listener.exitCaseExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseExpression" ):
                return visitor.visitCaseExpression(self)
            else:
                return visitor.visitChildren(self)




    def caseExpression(self):

        localctx = CypherParser.CaseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_caseExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 747
            self.match(CypherParser.CASE)
            self.state = 749
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 35320872390656) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 130027633) != 0):
                self.state = 748
                self.expression()


            self.state = 756 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 751
                self.match(CypherParser.WHEN)
                self.state = 752
                self.expression()
                self.state = 753
                self.match(CypherParser.THEN)
                self.state = 754
                self.expression()
                self.state = 758 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==80):
                    break

            self.state = 762
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==82:
                self.state = 760
                self.match(CypherParser.ELSE)
                self.state = 761
                self.expression()


            self.state = 764
            self.match(CypherParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self):
            return self.getToken(CypherParser.DOLLAR, 0)

        def symbol(self):
            return self.getTypedRuleContext(CypherParser.SymbolContext,0)


        def numLit(self):
            return self.getTypedRuleContext(CypherParser.NumLitContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = CypherParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 766
            self.match(CypherParser.DOLLAR)
            self.state = 769
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [30, 31, 32, 33, 34, 35, 89, 90]:
                self.state = 767
                self.symbol()
                pass
            elif token in [93]:
                self.state = 768
                self.numLit()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolLit(self):
            return self.getTypedRuleContext(CypherParser.BoolLitContext,0)


        def numLit(self):
            return self.getTypedRuleContext(CypherParser.NumLitContext,0)


        def NULL_W(self):
            return self.getToken(CypherParser.NULL_W, 0)

        def stringLit(self):
            return self.getTypedRuleContext(CypherParser.StringLitContext,0)


        def charLit(self):
            return self.getTypedRuleContext(CypherParser.CharLitContext,0)


        def listLit(self):
            return self.getTypedRuleContext(CypherParser.ListLitContext,0)


        def mapLit(self):
            return self.getTypedRuleContext(CypherParser.MapLitContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = CypherParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_literal)
        try:
            self.state = 778
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [71, 72]:
                self.enterOuterAlt(localctx, 1)
                self.state = 771
                self.boolLit()
                pass
            elif token in [93]:
                self.enterOuterAlt(localctx, 2)
                self.state = 772
                self.numLit()
                pass
            elif token in [73]:
                self.enterOuterAlt(localctx, 3)
                self.state = 773
                self.match(CypherParser.NULL_W)
                pass
            elif token in [92]:
                self.enterOuterAlt(localctx, 4)
                self.state = 774
                self.stringLit()
                pass
            elif token in [91]:
                self.enterOuterAlt(localctx, 5)
                self.state = 775
                self.charLit()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 6)
                self.state = 776
                self.listLit()
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 7)
                self.state = 777
                self.mapLit()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RangeLitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULT(self):
            return self.getToken(CypherParser.MULT, 0)

        def numLit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.NumLitContext)
            else:
                return self.getTypedRuleContext(CypherParser.NumLitContext,i)


        def RANGE(self):
            return self.getToken(CypherParser.RANGE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_rangeLit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRangeLit" ):
                listener.enterRangeLit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRangeLit" ):
                listener.exitRangeLit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRangeLit" ):
                return visitor.visitRangeLit(self)
            else:
                return visitor.visitChildren(self)




    def rangeLit(self):

        localctx = CypherParser.RangeLitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_rangeLit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 780
            self.match(CypherParser.MULT)
            self.state = 782
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==93:
                self.state = 781
                self.numLit()


            self.state = 788
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 784
                self.match(CypherParser.RANGE)
                self.state = 786
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==93:
                    self.state = 785
                    self.numLit()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolLitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(CypherParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(CypherParser.FALSE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_boolLit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolLit" ):
                listener.enterBoolLit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolLit" ):
                listener.exitBoolLit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolLit" ):
                return visitor.visitBoolLit(self)
            else:
                return visitor.visitChildren(self)




    def boolLit(self):

        localctx = CypherParser.BoolLitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_boolLit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 790
            _la = self._input.LA(1)
            if not(_la==71 or _la==72):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumLitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(CypherParser.DIGIT, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_numLit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumLit" ):
                listener.enterNumLit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumLit" ):
                listener.exitNumLit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumLit" ):
                return visitor.visitNumLit(self)
            else:
                return visitor.visitChildren(self)




    def numLit(self):

        localctx = CypherParser.NumLitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_numLit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 792
            self.match(CypherParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringLitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(CypherParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_stringLit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLit" ):
                listener.enterStringLit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLit" ):
                listener.exitStringLit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLit" ):
                return visitor.visitStringLit(self)
            else:
                return visitor.visitChildren(self)




    def stringLit(self):

        localctx = CypherParser.StringLitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_stringLit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 794
            self.match(CypherParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CharLitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHAR_LITERAL(self):
            return self.getToken(CypherParser.CHAR_LITERAL, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_charLit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharLit" ):
                listener.enterCharLit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharLit" ):
                listener.exitCharLit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCharLit" ):
                return visitor.visitCharLit(self)
            else:
                return visitor.visitChildren(self)




    def charLit(self):

        localctx = CypherParser.CharLitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_charLit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 796
            self.match(CypherParser.CHAR_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ListLitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACK(self):
            return self.getToken(CypherParser.LBRACK, 0)

        def RBRACK(self):
            return self.getToken(CypherParser.RBRACK, 0)

        def expressionChain(self):
            return self.getTypedRuleContext(CypherParser.ExpressionChainContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_listLit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListLit" ):
                listener.enterListLit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListLit" ):
                listener.exitListLit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListLit" ):
                return visitor.visitListLit(self)
            else:
                return visitor.visitChildren(self)




    def listLit(self):

        localctx = CypherParser.ListLitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_listLit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 798
            self.match(CypherParser.LBRACK)
            self.state = 800
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 35320872390656) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 130027633) != 0):
                self.state = 799
                self.expressionChain()


            self.state = 802
            self.match(CypherParser.RBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MapLitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(CypherParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(CypherParser.RBRACE, 0)

        def mapPair(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.MapPairContext)
            else:
                return self.getTypedRuleContext(CypherParser.MapPairContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.COMMA)
            else:
                return self.getToken(CypherParser.COMMA, i)

        def getRuleIndex(self):
            return CypherParser.RULE_mapLit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMapLit" ):
                listener.enterMapLit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMapLit" ):
                listener.exitMapLit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMapLit" ):
                return visitor.visitMapLit(self)
            else:
                return visitor.visitChildren(self)




    def mapLit(self):

        localctx = CypherParser.MapLitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_mapLit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 804
            self.match(CypherParser.LBRACE)
            self.state = 813
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 30)) & ~0x3f) == 0 and ((1 << (_la - 30)) & 2305843009213693951) != 0):
                self.state = 805
                self.mapPair()
                self.state = 810
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==11:
                    self.state = 806
                    self.match(CypherParser.COMMA)
                    self.state = 807
                    self.mapPair()
                    self.state = 812
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 815
            self.match(CypherParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MapPairContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(CypherParser.NameContext,0)


        def COLON(self):
            return self.getToken(CypherParser.COLON, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_mapPair

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMapPair" ):
                listener.enterMapPair(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMapPair" ):
                listener.exitMapPair(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMapPair" ):
                return visitor.visitMapPair(self)
            else:
                return visitor.visitChildren(self)




    def mapPair(self):

        localctx = CypherParser.MapPairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_mapPair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 817
            self.name()
            self.state = 818
            self.match(CypherParser.COLON)
            self.state = 819
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol(self):
            return self.getTypedRuleContext(CypherParser.SymbolContext,0)


        def reservedWord(self):
            return self.getTypedRuleContext(CypherParser.ReservedWordContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = CypherParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_name)
        try:
            self.state = 823
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [30, 31, 32, 33, 34, 35, 89, 90]:
                self.enterOuterAlt(localctx, 1)
                self.state = 821
                self.symbol()
                pass
            elif token in [36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88]:
                self.enterOuterAlt(localctx, 2)
                self.state = 822
                self.reservedWord()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SymbolContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ESC_LITERAL(self):
            return self.getToken(CypherParser.ESC_LITERAL, 0)

        def ID(self):
            return self.getToken(CypherParser.ID, 0)

        def COUNT(self):
            return self.getToken(CypherParser.COUNT, 0)

        def FILTER(self):
            return self.getToken(CypherParser.FILTER, 0)

        def EXTRACT(self):
            return self.getToken(CypherParser.EXTRACT, 0)

        def ANY(self):
            return self.getToken(CypherParser.ANY, 0)

        def NONE(self):
            return self.getToken(CypherParser.NONE, 0)

        def SINGLE(self):
            return self.getToken(CypherParser.SINGLE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_symbol

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymbol" ):
                listener.enterSymbol(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymbol" ):
                listener.exitSymbol(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSymbol" ):
                return visitor.visitSymbol(self)
            else:
                return visitor.visitChildren(self)




    def symbol(self):

        localctx = CypherParser.SymbolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_symbol)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 825
            _la = self._input.LA(1)
            if not(((((_la - 30)) & ~0x3f) == 0 and ((1 << (_la - 30)) & 1729382256910270527) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReservedWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL(self):
            return self.getToken(CypherParser.ALL, 0)

        def ASC(self):
            return self.getToken(CypherParser.ASC, 0)

        def ASCENDING(self):
            return self.getToken(CypherParser.ASCENDING, 0)

        def BY(self):
            return self.getToken(CypherParser.BY, 0)

        def CREATE(self):
            return self.getToken(CypherParser.CREATE, 0)

        def DELETE(self):
            return self.getToken(CypherParser.DELETE, 0)

        def DESC(self):
            return self.getToken(CypherParser.DESC, 0)

        def DESCENDING(self):
            return self.getToken(CypherParser.DESCENDING, 0)

        def DETACH(self):
            return self.getToken(CypherParser.DETACH, 0)

        def EXISTS(self):
            return self.getToken(CypherParser.EXISTS, 0)

        def LIMIT(self):
            return self.getToken(CypherParser.LIMIT, 0)

        def MATCH(self):
            return self.getToken(CypherParser.MATCH, 0)

        def MERGE(self):
            return self.getToken(CypherParser.MERGE, 0)

        def ON(self):
            return self.getToken(CypherParser.ON, 0)

        def OPTIONAL(self):
            return self.getToken(CypherParser.OPTIONAL, 0)

        def ORDER(self):
            return self.getToken(CypherParser.ORDER, 0)

        def REMOVE(self):
            return self.getToken(CypherParser.REMOVE, 0)

        def RETURN(self):
            return self.getToken(CypherParser.RETURN, 0)

        def SET(self):
            return self.getToken(CypherParser.SET, 0)

        def SKIP_W(self):
            return self.getToken(CypherParser.SKIP_W, 0)

        def WHERE(self):
            return self.getToken(CypherParser.WHERE, 0)

        def WITH(self):
            return self.getToken(CypherParser.WITH, 0)

        def UNION(self):
            return self.getToken(CypherParser.UNION, 0)

        def UNWIND(self):
            return self.getToken(CypherParser.UNWIND, 0)

        def AND(self):
            return self.getToken(CypherParser.AND, 0)

        def AS(self):
            return self.getToken(CypherParser.AS, 0)

        def CONTAINS(self):
            return self.getToken(CypherParser.CONTAINS, 0)

        def DISTINCT(self):
            return self.getToken(CypherParser.DISTINCT, 0)

        def ENDS(self):
            return self.getToken(CypherParser.ENDS, 0)

        def IN(self):
            return self.getToken(CypherParser.IN, 0)

        def IS(self):
            return self.getToken(CypherParser.IS, 0)

        def NOT(self):
            return self.getToken(CypherParser.NOT, 0)

        def OR(self):
            return self.getToken(CypherParser.OR, 0)

        def STARTS(self):
            return self.getToken(CypherParser.STARTS, 0)

        def XOR(self):
            return self.getToken(CypherParser.XOR, 0)

        def FALSE(self):
            return self.getToken(CypherParser.FALSE, 0)

        def TRUE(self):
            return self.getToken(CypherParser.TRUE, 0)

        def NULL_W(self):
            return self.getToken(CypherParser.NULL_W, 0)

        def CONSTRAINT(self):
            return self.getToken(CypherParser.CONSTRAINT, 0)

        def DO(self):
            return self.getToken(CypherParser.DO, 0)

        def FOR(self):
            return self.getToken(CypherParser.FOR, 0)

        def REQUIRE(self):
            return self.getToken(CypherParser.REQUIRE, 0)

        def UNIQUE(self):
            return self.getToken(CypherParser.UNIQUE, 0)

        def CASE(self):
            return self.getToken(CypherParser.CASE, 0)

        def WHEN(self):
            return self.getToken(CypherParser.WHEN, 0)

        def THEN(self):
            return self.getToken(CypherParser.THEN, 0)

        def ELSE(self):
            return self.getToken(CypherParser.ELSE, 0)

        def END(self):
            return self.getToken(CypherParser.END, 0)

        def MANDATORY(self):
            return self.getToken(CypherParser.MANDATORY, 0)

        def SCALAR(self):
            return self.getToken(CypherParser.SCALAR, 0)

        def OF(self):
            return self.getToken(CypherParser.OF, 0)

        def ADD(self):
            return self.getToken(CypherParser.ADD, 0)

        def DROP(self):
            return self.getToken(CypherParser.DROP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_reservedWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReservedWord" ):
                listener.enterReservedWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReservedWord" ):
                listener.exitReservedWord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReservedWord" ):
                return visitor.visitReservedWord(self)
            else:
                return visitor.visitChildren(self)




    def reservedWord(self):

        localctx = CypherParser.ReservedWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_reservedWord)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 827
            _la = self._input.LA(1)
            if not(((((_la - 36)) & ~0x3f) == 0 and ((1 << (_la - 36)) & 9007199254740991) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





